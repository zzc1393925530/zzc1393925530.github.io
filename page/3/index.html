<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Buscar"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-递归" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/23/递归/" class="article-date">
  <time datetime="2018-03-23T02:41:17.000Z" itemprop="datePublished">2018-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/23/递归/">递归</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>1.递归函数是在一个函数通过名字调用自身的情况下构成的。</h1><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num) &#123;</span><br><span class="line">if(num &lt;= 1)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return num * factorial(num-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var anotherFactorial = factorial;</span><br><span class="line">factorial = null;</span><br><span class="line">alert(anotherFactorial(4));  //Uncaught TypeError: factorial is not a function</span><br></pre></td></tr></table></figure><p></p>
<p></p><h2>arguments.callee是一个指向正在执行的函数的指针，可以用它实现对函数的递归调用。</h2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num) &#123;</span><br><span class="line">if(num &lt;= 1)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return num * arguments.callee(num-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var anotherFactorial = factorial;</span><br><span class="line">factorial = null;</span><br><span class="line">alert(anotherFactorial(4)); //24</span><br></pre></td></tr></table></figure><p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/23/递归/" data-id="cjfgetcqa00292kv2nalqii1e" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery类库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/18/jQuery类库/" class="article-date">
  <time datetime="2018-03-18T07:18:54.000Z" itemprop="datePublished">2018-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/18/jQuery类库/">jQuery类库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>////jQuery基础<br>jQuery类库定义了一个全局函数:jQuery()，快捷别名$.<br>e.g. var divs = $(“div”); 返回的值表示零个或多个DOM元素，这就是jQuery对象。 jQuery()是工厂函数，不是构造函数，返回一个新创建的对象。<br>////jQuery()函数<br>1、传递CSS选择器(字符串)给$()方法。<br>2、传递一个Element、Document或Window对象给$()方法。被封装成jQuery对象并返回。<br>3、传递HTML文本字符串给$()方法。$()接受可选的第二参数，可以传递Document对象来指定与所创建元素相关联的文档。<br>4、传入一个函数给$()方法。传给jQuery()的函数在被调用时，this指向document对象，唯一的参数指向jQuery函数。<br>////查询与查询结果 $()的返回值是一个jQuery对象，是类数组。<br>e.g. $(“body”).length  //=&gt;1:文档只有唯一一个body元素<br>     $(“body”)[0]   //等于document.body<br>     selector属性是创建jQuery对象时的选择器字符串。context属性是上下文对象，是传递给$()方法的第二参数，默认Document对象。所有jQuery对象都有一个名为jQuery的属性。<br>////想要遍历jQuery对象中的元素时，可以调用each()方法来代替for()循环。但是如果回调函数在任一元素上返回false，遍历在该元素后中止。jQuery的map()方法和Array.prototype.map()方法很接近。元素作为this值和第二参数传入，元素的索引值作为第一参数传入。另一个基础方法是index()。接受一个元素作为参数，返回值是该元素在此jQuery对象中的索引值，找不到返回-1。is()方法接受一个选择器作为参数，如果选中元素中至少有一个匹配该选择器时返回true。<br>jQuery中的getter和setter<br>//获取和设置HTML属性 attr()方法是jQuery中用于HTML属性的setter和getter。处理浏览器的兼容性和一些特殊情况，还让HTML属性名和JavaScript属性名可以等同使用。removeAttr()可用来从所有选中元素中移除某个属性。<br>e.g. $(“form”).attr(“action”);  //获取第一个form元素的action属性<br>     $(“#icon”).attr(“src”,”icon.gif”);  //设置src属性<br>     $(“#banner”).attr({  //一次设置4个属性<br>         src: “banner.gif”,<br>         alt: “Advertisement”,<br>         width: 720, height: 64<br>     });<br>     $(“a”).attr(“target”,”_blank”);  //使所有链接在新窗口中打开<br>     $(“a”).attr(“target”,function() {  //使站内链接在本窗口中打开，并且让<br>         if(this.host == location.host)<br>         return “_self”<br>         else return “_blank”;  //非站内链接在新窗口打开<br>     });<br>     $(“a”).attr({target: function() {  //可以像这样传入函数<br>         …<br>     }});<br>     $(“a”).removeAttr(“target”);  //让所有链接在本窗口中打开<br>//获取和设置CSS属性 css()方法和attr()方法类似，只是css()方法作用于元素的CSS样式，非HTML属性。返回的值是元素的当前样式，不能获取复合样式的值。<br>e.g. $(“h1”).css(“font-weight”);  //获取第一个 h1 的字体重量<br>     $(“h1”).css(“fontWeight”);  //也可采用驼峰格式<br>     $(“h1”).css(“font”);  //错误，不可获取复合样式<br>     $(“h1”).css(“font-variant”,”smallcaps”);  //将样式设置在所有 h1 元素上<br>     $(“div.note”).css(“border”,”solid black 2px”);  //设置复合样式是OK的<br>     $(“h1”).css({<br>         backgroundColor: “black”,<br>         textColor: “white”,<br>         fontVariant: “small-caps”,<br>         padding: “10px 2px 4px 20px”,<br>         border: “dotted black 4px”<br>     });  //一次设置多个样式<br>     $(“h1”).css(“font-size”,function(i,curval) {<br>         return Math.round(1.25 * parseInt(curval));<br>     });  //让所有 h1 的字体大小增加 25%<br>//获取和设置CSS类 addClass()从选中元素添加类 removeClass()删除类 toggleClass()当元素没有某些类时，给元素添加类，反之则删除。hasClass()判断类是否存在，只能接受单个类名作为参数，并且不支持函数参数。<br>e.g. // 添加CSS类<br>     $(“h1”).addClass(“hilite”); //给所有 h1 元素添加一个类<br>     $(“h1+p”).addClass(“hilite first”); //给 h1 后面的 p 添加两个类<br>//获取和设置HTML表单值 val()方法来设置和获取HTML表单元素的value属性，还可用于获取和设置复选框、单选按钮以及 select 元素的选中状态。<br>e.g. $(“#surname”).val();  //获取surname文本域的值<br>     $(“input:radio[name=ship]:checked”).val();  //获取选中的单选按钮的值。<br>     $(“input:checkbox”).val([“opt1”,”opt2”]);  //选中带有这些名字或值的复选框<br>//设置和获取元素内容 text()和html()方法用来获取和设置元素的纯文本或HTML内容。不带参数调用时，text()返回所有匹配元素的所有子孙文本节点的纯文本内容，html()返回第一个匹配元素的HTML内容。传入字符串给text()或html()，该字符串会用作该元素的纯文本或格式化的HTML文本内容，替换掉所有存在的内容。<br>e.g. var title = $(“head title”).text();  //获取文档标题<br>     var headline = $(“h1”).html();  //获取第一个 h1 元素的html<br>     $(“h1”).text(function(n,current){  //给每个标题添加章节号<br>         return “#” + (n+1) + “: “ + current<br>     });</p>
<p>/<br>/<br>/<br>/<br>////jQuery中的Ajax<br>//使用HTTP脚本按需加载数据，而不需要刷新整个页面。jQuery定义了一个高级工具方法和四个高级工具函数，这些工具都基于jQuery.ajax()。<br>//load()方法，向它传入一个url，它会异步加载该url的内容，然后将内容插入每一个选中元素中，替换掉已存在的任何内容。<br>e.g.  setInterval(function(){<br>    $(‘#status’).load(“status_report.html”);<br>},6000);<br>只想显示被加载文档的一部分，可以在URL后面添加一个空格和一个jQuery选择器。当URL加载完成后，jQuery会用指定的选择器来从加载好的html中选取需要显示的部分。<br>e.g.  $(‘#temp’).load(“wheater_report.html #temperature”);<br>除了必须的URL参数，load()方法接受两个可选参数。第一个可选参数表示的数据，可以追加到URL后面，或者与请求一起发送。传入的是字符串，则会追加到URL后面(放在”?”或”&amp;”后面)。传入对象，该对象会被转换成一个用”&amp;”分隔的键值对后与请求一起发送。通常情况下，load()方法发送HTTP GET请求，传入数据对象发送POST请求。<br>e.g.  $(‘#temp’).load(“us_weather_report.html”,”zipcode=01234”); //加载特定区号的天气预报<br>      $(‘#temp’).load(“us_weather_report.html”,{ zipcode: 01234,units: ‘f’});  //使用对象作为数据，并指定为华氏温度<br>load()方法的另一个可选参数是回调函数。当Ajax请求成功或未成功，以及(当请求成功时)URL加载完毕并插入选中元素时，会调用该回调函数。未指定任何数据下，回调函数作为第二个参数传入。否则必须是第三个参数。jQuery对象每一个元素上都会调用回调函数，并且每次调用都会调用都会传入三个参数：被加载URL的完整文本内容、状态码字符串，以及用来记载URL的XMLHttpRequest对象。状态码是jQuery的，类似”success”、”error”、”timeout”.<br>//Ajax工具函数 jQuery的其他Ajax高级工具是函数非方法，可通过jQuery或$直接调用。<br>1、jQuery.getScript() 第一个参数是JavaScript代码文件的URL。异步加载文档，加载完成后再全局作用域执行代码。适用于同源和跨源脚本。<br>e.g.  jQuery.getScript(“<a href="http://example.com/js/widget.js&quot;)" target="_blank" rel="noopener">http://example.com/js/widget.js&quot;)</a>;<br>可以传入回调函数作为第二参数，jQuery会在代码加载和执行完成后调用一次该回调函数。<br>e.g.  //加载一个类库，并在加载完成时立刻使用它<br>     jQuery.getScript(“js/jquery.my_plugin.js”,function() {<br>     $(‘div’).my_plugin();  //使用加载的类库<br>    });<br>jQuery.getScript()通常会使用XMLHttpRequest对象获取执行的脚本内容。跨域请求，jQuery使用 script 加载脚本。同源下，回调函数第一个参数是脚本的文本内容，第二参数是”success”状态码，第三参数是用来获取脚本内容的XMLHttpRequest对象，jquery.getScript()函数的返回值也是XMLHttpRequest对象。跨源，不存在XMLHttpRequest对象，无法获取脚本内容。回调函数第一参数和第三参数是undefined,jQuery.getScript()的返回值也是undefined.<br>传递给jQuery.getScript()回调函数在请求成功时才被调用。若需要在发生错误和成功时得到通知则需要底层jQuery.ajax()函数。<br>2、jQuery.getJSON() 获取文本特殊处理，调用指定的回调函数。jQuery.getJSON()获取到文本后解析为JSON。此方法在传入了回调函数时才有用。成功加载URL将内容成功解析成JSON后，解析结果会作为第一个参数传入回调函数中。与jquery.getScript()一样回调函数的第二个和第三个参数是”success”状态码和XMLHttpRequest对象。<br>e.g.  //假设data.json包含文本: ‘{“x”:1,”y”:2}’<br>      jQuery.getJSON(“data.json”,function(data){<br>          //data参数是对象{x:1,y:2}<br>})<br>该方法接受一可选的数据对象参数，和load()方法一样。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/18/jQuery类库/" data-id="cjfgetcqa001u2kv2p8rfwncu" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-脚本化文档" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/脚本化文档/" class="article-date">
  <time datetime="2018-03-17T07:41:44.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/脚本化文档/">脚本化文档</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通过id选取元素：document.getElementsById() id属性必须唯一<br>通过名字选取元素：document.getElementsByName() name属性不必唯一，该方法定义在HTMLDocument类中，而不在Document类中，所以只针对HTML文档可用，在xml文档中不可用。返回nodeList集合，只在少数DOM元素中有效。<strong>在IE中该方法也返回id属性匹配指定值的元素。</strong><br>通过标签名选取元素：document.getElementsByTagName() 返回nodeList集合<br>e.g. 查找文档中第一个 p 元素里面的所有 span 元素<br>     var firstpara = document.getElementsByTagName(“p”)[0];<br>     var firstParaSpans = firstpara.getElementsByTagName(“span”);<br>e.g. 引用命名(或有ID的)表单<br>     document.form.shipping_address;<br>通过CSS类选取元素：document.getElementsByClassName()<br>返回nodeList集合，只能选取调用该方法的元素的后代元素。IE8及其以下版本的浏览器未实现。<br>通过CSS选择器选取元素：可以通过ID、名字、标签名、类名选取元素。document.querySelectorAll(“selector”) 返回值是nodeLIst集合 IE8及其以下版本的浏览器只支持CSS2标准的选择器语法。<br>document.all[]表示所有文档中的元素，除了Text节点。<br>////文档结构和遍历<br>parentNode 该节点的父节点 Document没有父节点<br>childNode 只读的类数组对象(NodeList对象)<br>firstChild、lastChild 该节点的第一个和最后一个，没有子节点则null<br>nextSibling、previoursSibling该节点的兄弟节点中的前一个和下一个。具有相同父节点的两个节点为兄弟节点。顺序反映了在文档中的出现顺序。<br>nodeType 节点类型。9代表Document节点，1代表Element节点，3代表Text节点，8代表Comment节点，11代表DocumentFragment节点。<br>nodeValue Text节点或Comment节点的文本内容<br>nodeName 元素的标签名，以大写形式表示。<br>////作为元素树的文档<br>API第一部分是Element对象的children属性。NodeList对象，但只包含Element对象。Text和Comment节点没有children属性，上述Node.parentNode属性不可能返回Text或Comment节点。<br>基于元素的文档遍历api第二部分是Element属性。<br>////属性<br>HTMLElement定义了通用的HTTP属性(id、标题lang和dir)属性，以及事件处理程序属性(onclick)。HTML属性名不区分大小写，从HTML属性名转到JavaScript属性名应小写。属性名不止一个单词则除首单词以外的单词首字母大写。HTML属性名在JavaScript中是保留字则在属性名前加html。<br>////设置和获取非标准的HTML属性<br>getAttribute()和setAttribute()方法，查询和设置非标准的HTML属性。Element属性还设置了hasAttribute()检测属性是否存在，removeAttribute()删除属性。<br>////元素的内容<br>查询纯文本形式的元素内容，或在文档中插入纯文本。作为纯文本的元素内容 Node的textContent属性<br>e.g. var para = document.getElementByTagName(“p”)[0];<br>     var text = para.textContent;<br>     para.textContent = “Hello World!”;<br>作为Text节点的元素内容<br>e.g. 查找元素的后代中节点的所有Text节点】】<br>    function textContent(e) {<br>    var child,type,s = “”;<br>    for(child = e.firstChild;child != null; child = child.nextSibling){<br>        type = child.nodeType;<br>        if(type === 3 || type === 4 )<br>        s += child.nodeValue;<br>        else if (type === 1)<br>        s += textConetent(child);<br>    }<br>    return s;<br>}<br>////创建、插入和删除节点<br>创建节点 text节点 var newnode = document.createTextNode(“text node content”);<br>每个节点有一个cloneNode()方法返回该节点的一个全新副本。参数true能递归的复制所有后代节点，false执行浅复制。<br>插入节点 appendChild()(插入的节点使其成为那个节点的最后一个子节点)或insertBefore()(接受两个参数 1待插入的节点2已存在的节点)<br>删除和替换节点 removeChild()从文档树删除一个节点，在其父节点上调用，并将需要删除的子节点作为方法参数传递(两个参数1新节点2需要代替的节点)。n.parentNode.removeChild(n);</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/17/脚本化文档/" data-id="cjfgetcqq002b2kv257nzvju5" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浏览器中的JavaScript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/浏览器中的JavaScript/" class="article-date">
  <time datetime="2018-03-17T02:34:53.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/浏览器中的JavaScript/">浏览器中的JavaScript</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>////Window、Document和Element对象事件处理程序相关。在脚本中绑定函数，事件发生时异步调用。事件处理程序属性名以单词’on’开始。<br>////WEB文档里的JavaScript 内容、呈现和行为的组合，叫做动态HTML或DHTML。文档里应少量食用JavaScript。<br>////WEB应用里的JavaScript WEB应用从服务器获取新信息，不用重新载入界面称为AJAXA应用。代码和文档来自不同的源 有重要的安全隐患。<br>////javascript:URL能识别的资源是转换成字符串的执行代码的返回值。alert返回undefined.JavaScript:URL在文档之外确实有重要角色，但应该避免在HTML中使用。<br>/////JavaScript:URL应用:书签<br>////客户端JavaScript线程模型：严格的单线程，HTML5定义了一个并发控制方式WEB WORKER：执行计算密集任务而不冻结用户界面的后台线程。<br>。<br>////兼容性和互用性<br>/////检测渲染模式document.compatMode,值为”CSS1Compat”标准模式，值为”BackCompat”或undefined则为怪异模式。<br>////IE里的条件注释<br>/////   /<em>@cc_on<br>          @</em>/<br>////可访问性<br>/////应该尽可能支持独立于设备的事件<br>////安全性<br>/////JavaScript不支持某些功能。例如不能删除数据或植入病毒。<br>/////在自己支持的某些功能上施加限制。<br>////同源策略 脚本只能读取和所属文档来源相同的窗口和文档的属性，文档的来源包括协议、主机，以及载入文档的URL端口。<br>////不严格的同源策略<br>/////1.document.domain属性设置为一个源<br>/////2.跨域资源共享：允许服务器用头信息显式地列出源，或使用通配符匹配所有源并允许由任何地址请求文件。<br>/////3.跨文档消息：允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本。调用Window对象上的postMessage()方法，可以异步传递消息事件到窗口的文档里。<br>////跨站脚本<br>/////防止XSS攻击的方式是，在使用任何不可信的数据来动态的创建文档内容之前，从中移除HTML标签。<br>     e.g. name = name.replace(/&lt;/g,”&lt;”).replace(/&gt;/g,”&gt;”);<br>     html5为iframe元素定义了sandbox属性，在实现之后，允许显示不可信内容并自动禁用脚本。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/17/浏览器中的JavaScript/" data-id="cjfgetcqa00232kv2nbdtm32t" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript函数4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/JavaScript函数4/" class="article-date">
  <time datetime="2018-03-17T02:28:09.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/JavaScript函数4/">JavaScript函数4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>///函数属性、方法和构造函数<br>   length属性 arguments.length表示传入函数的实参的个数。函数的length属性只读，代表函数实参的数量，参数指的是形参而非实参，就是函数定义时给出的实参个数。<br>   prototype属性 每个函数都包含一个prototype属性，指向一个对象的引用，原型对象。将函数用作构造函数时，新创建的对象会从原型对象继承属性。<br>   call()和apply()方法 看作某个对象的方法，通过调用方法的形式间接调用。call()和apply()方法的第一个实参调用函数的母对象，调用上下文，在函数体内通过this获得对它的引用。继承自function.prototype<br>   e.g. f.call(o);<br>        f.apply(o); //以对象o的方法调用函数f()<br>    call() 第一个参数是指定函数内部中this的指向(函数执行时所在作用域)，第二个参数是函数调用时需要传递的参数。可以指定该函数内部this的指向，即函数执行时所在的作用域，然后在所指定的作用域中，调用该函数，并且会立即执行该函数。e.g. f.call(0,1,2)<br>    e.g. var keith = {<br>        rascal: 123<br>    };<br>         var rascal = 456;<br>         function a() {<br>             console.log(this.rascal);<br>         }<br>         a();  //456<br>         a.call(); //456<br>         a.call(null); //456<br>         a.call(undefined); //456<br>         a.call(this); //456:以上作用域均为a()函数<br>         a.call(keith); //123：作用域keith对象<br>    e.g. function keith(a,b) {<br>        console.log(a + b);<br>    }<br>    keith.call(null,1,2); //3:第一个参数为null，undefined，this表明函数此时处于全局作用域。apply必须以数组的形式添加。<br>bind()方法 用于指定函数内部的this指向(执行时所在的作用域)，然后返回一个新函数。传递参数时和call()方法相同。<br>toString()方法 返回字符串<br>Function()构造函数 该函数创建的函数并不是使用词法作用域，函数体代码的编译总是会在顶层函数执行。<br>e.g. var scope = “global”;<br>     function constructFunction() {<br>         var scope = “local”;<br>         return new Function (“return scope”); //无法捕获局部作用域<br>     }<br>     //因为通过Function()构造函数<br>     //所返回的函数使用的不是局部作用域<br>     constructFunction()(); //=&gt;”global”<br>可调用对象 RegExp对象<br>////函数式编程<br>高阶函数：接受一个或多个函数作为参数返回一个新函数。<br>不完全函数：把一次完整的函数调用拆成多次函数调用，每次传入的参数都是完整实参的一部分。<br>记忆：memorize()函数创建一个新对象，这个对象被当做缓存并赋值给一个局部变量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/17/JavaScript函数4/" data-id="cjfgetcp0000k2kv24puy11vv" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript函数3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/JavaScript函数3/" class="article-date">
  <time datetime="2018-03-17T02:27:00.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/JavaScript函数3/">JavaScript函数3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>////闭包<br>    JavaScript也采用词法作用域，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内。<br>    作用域<br>    e.g. var scope = “global”;<br>         function f() {<br>             console.log(scope); //输出undefined:局部变量在整个函数体始终有定义，局部变量遮盖同名全局变量<br>             var scope = “local”; //变量在这里赋值，但变量本身在函数体内任何地方都有定义<br>             console.log(scope); //输出local<br>         }<br>         var scope = ‘global’;<br>          function fn() {<br>          alert(scope); //未定义直接赋值的变量自动声明为全局作用域，所以上例不适用，这里的scope就是global<br>          scope = ‘local’; //更改了全局变量scope值变为local<br>          alert(scope); //local<br>         }<br>        fn();<br>        alert(scope);//local</p>
<pre><code>var scope = &apos;global&apos;;
function fn(scope) { //scope此时是函数的参数
alert(scope); //为被初始化
scope = &apos;local&apos;; //局部变量
alert(scope);
}
fn();
alert(scope); //全局变量
</code></pre><p><strong>不使用var保留字声明变量, 变量提升为全局变量, 而不论变量处于哪种作用域;<br>如果不使用var声明, 该变量便可配置, 即可被 delete 保留字删除, 删除后该变量便不可访问; 如果使用var声明, 该变量便不可配置, 即不能被 delete 保留字删除;<br>只要是全局变量都可以直接访问, 也可使用 “window.变量名” 来访问, 不管该变量是不是通过var来声明的;</strong><br><strong>闭包 // 如果一个函数访问了它的外部变量，那么它就是闭包。当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。</strong><br>        闭包 e.g. var scope = “global scope”;<br>                 function checkscope() {<br>                 var scope = “local scope”;<br>                 function f() {return scope;}<br>                 return f();<br>                }<br>                checkscope(); //“local scope”</p>
<pre><code>        var scope = &quot;global scope&quot;;
        function checkscope() {
        var scope = &quot;local scope&quot;;
        function f() {return scope;}
        return f;
        }
        checkscope()(); //&quot;local scope&quot;
e.g. function foo(x) {
    var temp = 3;
    function bar(y) {
        alert(x + y + (++temp));
    }
    bar(10);
}
foo(2); //16:非闭包
e.g. function foo(x) {
    var temp = 3;
    return function (y) {
        alert(x + y + (++temp));
    }
}
var bar = foo(2);
bar(10); //16:闭包
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/17/JavaScript函数3/" data-id="cjfgetcp0000h2kv239qcg70o" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript函数2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/JavaScript函数2/" class="article-date">
  <time datetime="2018-03-17T02:26:44.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/JavaScript函数2/">JavaScript函数2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>////函数的实参和形参<br>    1.可选形参<br>      当调用函数的时候传入的实参比函数声明时指定的参数个数要少，剩下的形参都设置为undefined值。保持适应性(合理默认值)。<br>    2.可变长的实参列表：实参对象<br>      函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象，可以通过数字下标访问传入函数的实参，只具有数字索引属性。通过实参名字修改实参值，通过arguments[]数组也可以获取到更改后的值。<br>    3.callee和caller属性<br>      严格模式下对着两个属性读写产生类型错误。非严格模式下，callee属性指代调用当前正在执行的函数的函数。通过caller属性访问调用栈。<br>      e.g. 通过callee递归调用自身<br>           var factorial = function(x) {<br>               if(x &lt;= 1) return 1;<br>               return x <em> arguments.callee(x-1);<br>           };<br>           console.log(factorial(4)); //24<br>    4.对象属性用作实参<br>      通过名/值对的形式传入参数。<br>      如果函数期望接收一个字符串参数，而调用函数时传入其他类型的值，所传入的值会在函数体内将其用做字符串的地方转换为字符串类型。<br>////作为值的函数<br>    在JavaScript中，函数不仅是一种语法，也是值。<br>    e.g. var a = [function(x) {return x</em>x},20];<br>         a<a href="a[1]">0</a>; //=&gt;400<br>         function add(x,y){ return x + y; }<br>         function subtract(x,y){ return x - y; }<br>         function multiply(x,y){ return x <em> y; }<br>         function divide(x,y){ return x / y; }<br>        //以上面的某个函数作为参数，并传入两个操作数调用<br>         function operate(operator,operand1,operand2) {<br>             return operator(operand1,operand2);<br>         }<br>         var i = operate(add,operate(add,2,3),operate(multiply,4,5)); //(2+3)+(4</em>5)<br>////自定义函数属性<br>    当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的是给函数定义属性。<br>    e.g. uniqueInteger.counter = 0;<br>         function uniqueInteger() {<br>             return uniqueInteger.counter++;<br>         } // 0 先返回计数器的值然后计数器自增1</p>
<pre><code>function factorial(n) {
    if(isFinite(n) &amp;&amp; n&gt;0 &amp;&amp; n==Math.round(n)) {
        if(!(n in factorial)) //in 一个字符串类型或者 symbol 类型的属性名或者数组索引（非symbol类型将会强制转为字符串）。
        factorial[n] = n * factorial(n-1);
    }
    else return NaN;
}
factorial[1] = 1;
</code></pre><p>////作为命名空间的函数<br>    定义一个函数用作临时命名空间，在这个命名空间内定义的变量不会污染到全局命名空间。<br>    (function() {<br>        //模块代码<br>    }()); //结束函数定义并立即调用它 PAGE：182</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/17/JavaScript函数2/" data-id="cjfgetcp0000f2kv2p4zjqsjv" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript函数1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/JavaScript函数1/" class="article-date">
  <time datetime="2018-03-17T02:26:26.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/JavaScript函数1/">JavaScript函数1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>////函数调用：<br>    1.普通函数调用 printprops({x:1});<br>    2.方法调用 o.m = f;//函数f，对象o，m()方法<br>    <strong>关键字this没有作用域限制，嵌套的函数不会从调用它的函数中继承this。如果嵌套函数作为方法调用，其this的值指向调用它的对象。如果嵌套函数作为函数调用，其this不是全局对象就是undefined。</strong><br>    全局对象：<br>    全局作用域下，this指向全局对象。浏览器中全局对象就是window对象。<br>    e.g. function test(){<br>        return this;<br>    }<br>    test(); //window{}:this关键字没有处于一个声明的对象内部，默认指向全局window对象。<br>    声明的对象：<br>    当this关键字在一个声明对象内部使用，其值会被绑定到该this的函数的最近的父对象。<br>    e.g. var person = {<br>        first : ‘John’,<br>        last : ‘Smith’,<br>        full: function() {<br>            console.log(this.first + ‘ ‘ + this.last);<br>        }<br>        };<br>        person.full(); //在被声明的对象person中的full函数使用this，那么调用this的full函数的最近的父对象就是person，因此，this指向person。<br>        var person = {<br>            first : ‘John’,<br>            last : ‘Smith’,<br>            full: function() {<br>                console.log(this.first + ‘ ‘ + this.last);<br>            },<br>            personTwo : {<br>                first : ‘Allison’,<br>                last : ‘Jones’,<br>                full : function() {<br>                    console.log(this.first + ‘ ‘ + this.last);<br>                }<br>            }<br>        };<br>        person.full(); //John Smith<br>        person.personTwo.full(); //Allison Jones:调用this的full函数最近的父对象是personTwo，this指向personTwo。<br>    当使用new关键字构建一个新的对象，this会绑定到这个新对象。<br>    e.g. function Car(make,model) {<br>        this.make = make;<br>        this.model = model;<br>    };<br>    var myCar = new Car(‘Ford’,’Escape’);<br>    console.log(myCar); //Car {make: “Ford”, model: “Escape”}:使用new关键字来声明一个新的变量，Car函数中的this将会绑定一个新的空对象，然后初始化this.make和this.model的值。<br>    3.构造函数调用<br>    函数或方法调用之前带有关键字new，就构成构造函数调用。<br>    4.间接调用<br>    call() apply()方法间接调用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/17/JavaScript函数1/" data-id="cjfgetcp0000c2kv2gstb68nr" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript数组3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/14/JavaScript数组3/" class="article-date">
  <time datetime="2018-03-14T11:04:49.000Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/14/JavaScript数组3/">JavaScript数组3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ECMAScript5中的数组方法： <br><br>////forEach()从头到尾遍历数组没有break语句 提前终止需要将语句放到try块中，并抛出异常。<br>////map()将每个元素传递给制定函数返回<strong>新</strong>数组包含返回值。<br>e.g. a = [1,2,3];<br>     b = a.map(function(x){<br>         return x*x;<br>     }); // b [1,4,9]<br>////filter()调用数组的子集<br>e.g. a = [5,4,3,2,1];<br>    smallvalues = a.filter(function(x){<br>        return x &lt; 3;<br>    }); //[2,1]<br>    everyother = a.filter(function(x,i){ //x为数组元素，i是元素的索引<br>        return i%2 == 0;<br>    }); //[5,3,1]<br>////every()方法针对所有元素调用判定函数都返回true时返回true。<br>    some()方法存在即true。<br>////reduce()方法两个参数，第一个参数是执行化简的函数，第二个参数(可选)是传递给函数的初始值。<br>////reduceRight()方法工作原理与reduce()相同，不同的是按照数组索引从高到低处理。<br>////indexOf()搜索整个数组具有给定值返回找到的第一个元素的索引或没找到返回-1.indexOf()从头至尾，lastIndexOf()反向。不接收函数作为参数。<br>////Array.isArray([]); //=&gt; true</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/14/JavaScript数组3/" data-id="cjfgetcpf000z2kv2fpuzak0b" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript数组2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/14/JavaScript数组2/" class="article-date">
  <time datetime="2018-03-14T11:04:32.000Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/14/JavaScript数组2/">JavaScript数组2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数组方法： <br><br>////join()方法将数组中所有元素转换为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串分割数组的各个元素。Array.join()方法是String.split()方法的逆向操作。<br>e.g. var a = [1,2,3];<br>     a.join(); //“1,2,3”<br>     a.join(“ “); //“1 2 3”<br>     a.join(“”); //“123”<br>     var b = new Array(10);<br>     b.join(‘-‘); //‘———‘<br>////reverse()方法将数组中的元素颠倒顺序返回逆序的数组。替换<br>e.g. var a = [1,2,3];<br>     a.reverse().join(); //=&gt;”3,2,1”,现在的a是[3,2,1]<br>////sort()方法将数组中的元素排列并返回排列后的数组,不带参数调用该方法时以字母表顺序排序<br>e.g. var a = new Array(“bananan”,”apple”,”cherry”);<br>     a.sort();<br>     var s = a.join(“, “);<br>     console.log(s); //apple, bananan, cherry若包含undefined元素会被排到数组尾部<br>     为了按照其他方法而非字母表顺序排列 ，sort()方法传递一个比较函数。第一个参数在前，比较函数返回值小于0.<br>////concat()方法创建并返回一个新数组，元素包括调用concat()的原始数组的元素和concat()的每个参数。<br>e.g. var a = [1,2,3];<br>     a.concat(4,5); //[1,2,3,4,5]<br>     a.concat([4,5]); //[1,2,3,4,5]<br>     a.concat([4,5],[6,7]); //[1,2,3,4,5,6,7]<br>     a.concat(4,[5,[6,7]]); //[1,2,3,4,5,[6,7]]<br>////slice()方法返回指定数组的一个片段或子数组。返回的数组包含第一个参数指定的位置和所有到但不含第二个参数指定的位置之间的所有数组元素。<br>e.g. var a = [1,2,3,4,5]<br>     a.slice(1,-1); //[2,3,4]负数表示倒数第几个元素<br>////splice()方法在数组中插入或删除元素的通用方法。会更改调用的数组。<br>第一个参数指定插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除元素的个数。若被省略，从起始点到数组结尾的所有元素都被删除。返回被删除的元素。<br>e.g. var a = [1,2,3,4,5,6,7,8];<br>     a.splice(4); //返回[5,6,7,8],a是[1,2,3,4]<br>     a.splice(1,2); //返回[2,3],a是[1,4]<br>     a.splice(1,1); //返回[4],a是[1]<br>    前两个参数指定需要删除的数组元素，紧随其后的任意个数的参数指定插入到数组中的元素，从第一个参数指定的位置开始插入。<br>e.g. var a = [1,2,3,4,5];<br>     a.splice(2,0,’a’,’b’); //返回[];a是[1,2,’a’,’b’,3,4,5]<br>     a.splice(2,2,[1,2],3); //返回[‘a’,’b’];a是[1,2,[1,2],3,3,4,5]<br>toString()和toLocaleString()方法： <br><br>////toString()：每个元素转化为字符串，输出带逗号分隔的字符串列表，不包括分隔符。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/14/JavaScript数组2/" data-id="cjfgetcpf000w2kv298d6jfny" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Previo</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Siguiente &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categorías</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript笔记/">JavaScript笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript笔记/">JavaScript笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bootstrap/">bootstrap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开始/">开始</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日志/">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简介/">简介</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nube de Tags</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/HTML/" style="font-size: 12.5px;">HTML</a> <a href="/tags/HTML-CSS/" style="font-size: 15px;">HTML/CSS</a> <a href="/tags/JavaScript/" style="font-size: 17.5px;">JavaScript</a> <a href="/tags/JavaScript笔记/" style="font-size: 10px;">JavaScript笔记</a> <a href="/tags/bootstrap/" style="font-size: 10px;">bootstrap</a> <a href="/tags/开始/" style="font-size: 10px;">开始</a> <a href="/tags/日志/" style="font-size: 20px;">日志</a> <a href="/tags/简介/" style="font-size: 10px;">简介</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivos</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Posts recientes</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/01/JavaScript权威指南6/">JavaScript权威指南6</a>
          </li>
        
          <li>
            <a href="/2018/04/01/JavaScript权威指南5/">JavaScript权威指南5</a>
          </li>
        
          <li>
            <a href="/2018/03/31/JavaScript权威指南4/">JavaScript权威指南4</a>
          </li>
        
          <li>
            <a href="/2018/03/31/JavaScript权威指南3/">JavaScript权威指南3</a>
          </li>
        
          <li>
            <a href="/2018/03/31/JavaScript权威指南2/">JavaScript权威指南2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Construido por <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>