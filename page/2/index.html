<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-DIV-CSS1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/24/DIV-CSS1/" class="article-date">
  <time datetime="2018-03-24T07:34:48.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/24/DIV-CSS1/">DIV/CSS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h2>布局</h2><p></p>
<p></p><h3>Display</h3><br>&emsp;&emsp;block(块级元素): p form,HTML5中新元素:header,footer,section.||inline(行内元素): span a.||none:特殊元素默认display值，如script.display:none被JavaScript用来在不删除元素的情况下隐藏或显示元素。visibility:hidden还会占据空间，而display:none不会占据应该显示的空间。display可以重写。<p></p>
<p></p><h3>margin:auto</h3><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">    width: 600px;</span><br><span class="line">    margin 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>设置块级元素的width防止撑满容器，设置左右外边距auto使其水平居中。缺点是，浏览器窗口比元素宽度窄时，浏览器会显示水平滚动条容纳页面。</p>
<p></p><h3>max-width</h3><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">    max-width: 600px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>max-width代替width可以使浏览器更好的处理小窗口。主流浏览器包括IE7+都支持。</p>
<p></p><h3>盒模型之 box-sizing</h3><br>&emsp;&emsp;当设置一个元素为box-sizing: border-box;时，元素的内边距和边框不会增加宽度。使用-webkit-和-moz-前缀。<p></p>
<p></p><h3>positon</h3><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.static &#123;</span><br><span class="line">    positon: static;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>static是默认值。不会被特殊定位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.relative1 &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.relative2 &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  top: -20px;</span><br><span class="line">  left: 20px;</span><br><span class="line">  background-color: white;</span><br><span class="line">  width: 500px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>relative和static一样，除非添加额外的属性。在一个相对定位的元素上设置top,right,bottom,left属性会让元素偏离正常位置。其他元素不会受影响。原本所占空间依旧保留。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.fixed &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  width: 200px;</span><br><span class="line">  background-color: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fixed定位会相对视窗定位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.relative &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  width: 600px;</span><br><span class="line">  height: 400px;</span><br><span class="line">&#125;</span><br><span class="line">.absolute &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 120px;</span><br><span class="line">  right: 0;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>absolute相对于最近的positioned祖先元素。如果绝对定位的元素没有positioned祖先元素，那么相对于文档的body元素，会随着页面的滚动而移动。一个positioned的元素指position值不是static的元素。元素不占据空间。</p>
<p></p><h3>float</h3><br>float可用于实现文字环绕图片。clear属性用来控制浮动。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>...<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>section元素是在DIV之后的，div浮动到左边的，section中的文字围绕div。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"after-box"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.after-box</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用clear可以将section段落移动到浮动元素div下面。使用left才能清除元素的向左浮动。可以用right或both 清除向右或同时清除向左向右浮动。</p>
<p></p><h3>清除浮动</h3><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.clearfix &#123;</span><br><span class="line">    overflow: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>浮动的元素比包含它的元素高，使用clearfix hack解决问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.clearfix &#123;</span><br><span class="line">    overflow: auto;</span><br><span class="line">    zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><h3>百分百宽度</h3><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">article img &#123;</span><br><span class="line">  float: right;</span><br><span class="line">  width: 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>百分比可以用于布局，但需要更多的工作。</p>
<p></p><h3>媒体查询(响应式布局)</h3><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-width:600px) &#123;</span><br><span class="line">  nav &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 25%;</span><br><span class="line">  &#125;</span><br><span class="line">  section &#123;</span><br><span class="line">    margin-left: 25%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width:599px) &#123;</span><br><span class="line">  nav li &#123;</span><br><span class="line">    display: inline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>使用百分比宽度布局。在浏览器变窄到无法容纳侧边栏的菜单时，布局显示成一列。</p>
<p></p><h3>inline-block</h3><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box2 &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  margin: 1em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>vartical-align会影响inline-block元素；需要设置每一列宽度；HTML源码元素之间有空格，列与列会有空隙。</p>
<p></p><h3>column</h3><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.three-column &#123;</span><br><span class="line">  padding: 1em;</span><br><span class="line">  -moz-column-count: 3;</span><br><span class="line">  -moz-column-gap: 1em;</span><br><span class="line">  -webkit-column-count: 3;</span><br><span class="line">  -webkit-column-gap: 1em;</span><br><span class="line">  column-count: 3;</span><br><span class="line">  column-gap: 1em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/24/DIV-CSS1/" data-id="cjfeozu620006ssv2ixxdychm" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AJAX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/23/AJAX/" class="article-date">
  <time datetime="2018-03-23T11:27:20.000Z" itemprop="datePublished">2018-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/23/AJAX/">AJAX</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;AJAX, Asynchronous JavaScript and XML.异步JavaScript和XML。核心是XMLHttpRequest对象，能够以异步方式从服务器取得更多的信息，意味着用户单击后不必刷新页面也能取得数据。</p>
<p></p><h2>XMLHttpRequest对象</h2><br>XHR的用法<br>&emsp;&emsp;使用XHR对象时，要调用的第一个方法是open(),接收三个参数：要发送的请求的类型(get、post等)、请求的URL和表示是否异步发送请求的布尔值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;,&quot;example.php&quot;,false);</span><br></pre></td></tr></table></figure><p></p>
<p>这行代码会启动一个针对example.php的GET请求。注意，URL相对于执行代码的当前页面；调用open()方法不会真正发送请求，而是启动一个请求准备发送。<br><figure class="highlight plain"><figcaption><span>必须调用send()方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;,&quot;example.php&quot;,false);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure></p>
<p>这里的send()方法接收一个参数，即要作为请求主体发送的数据。不需要通过请求主体发送数据，则必须传入null。由于请求是同步的，JavaScript代码会等到服务器响应之后再继续执行。收到响应后，响应的数据会自动填充XHR对象的属性，属性简介：<br>responseText:作为响应主体被返回的文本<br>responseXML:如果响应的内容类型是”text/xml”或”application/xml”，这个属性将保存包含着响应数据的XML DOM文档<br>status:响应的HTTP状态<br>statusText:HTTP状态的说明<br>接收到响应后，第一步是检查status属性，以确定响应已经成功返回。一般来说，可以将HTTP状态代码为200作为成功的标志。此时，responseText属性的内容已经就绪，在内容类型正确的情况下，responseXML也能访问了。状态码304表示请求的资源并没有被修改，可直接使用浏览器中缓存的部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;,&quot;example.php&quot;,false);</span><br><span class="line">xhr.send(null);</span><br><span class="line">if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</span><br><span class="line">    alert(xhr.responseText);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    alert(&quot;Request was unsuccessful&quot; + xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段。0：未初始化 1：启动，调用open()方法未调用send()方法 2：发送，已经调用send()方法未收到回应 3：接收，已经接收到部分响应数据 4：完成，已经收到全部响应数据，已经在客户端使用。readyState属性值变化都会触发readystatechange事件。<br>收到响应之前可以调用abort()方法取消异步请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.abort();</span><br></pre></td></tr></table></figure></p>
<p>由于内存原因，不建议重用XHR对象。</p>
<p></p><h3>HTTP头部信息</h3><br>&emsp;&emsp;每个HTTP请求和响应都会带有相应的头部信息。使用setRequestHeader()方法可以设置自定义的请求头部信息。方法接收两个参数：头部字段的名称和头部字段的值。要成功发送请求头部信息，必须在调用open()之后且调用send()方法之前调用setRequestHeader()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;,&quot;example.php&quot;,true);</span><br><span class="line">xhr.setRequestHeader(&quot;MyHeader&quot;,&quot;MyValue&quot;);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure><p></p>
<p>&emsp;&emsp;调用XHR对象的getRequestHeader()方法并传入头部字段名称，可以取得相应的响应头部信息。调用getAllRequestHeaders()方法则可以取得一个包含所有包含所有头部信息的长字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myHader = xhr.getRequestHeader(&quot;MyHeader&quot;);</span><br><span class="line">var allHeaders xhr.getAllRequestHeaders();</span><br></pre></td></tr></table></figure></p>
<p></p><h3>GET请求</h3><br>&emsp;&emsp;GET是最常见的请求类型，最常用于向服务器查询某些信息。必要时将查询字符串参数追加到URL末尾，以便将信息发给服务器。对XHR而言，位于传入open()方法的URL末尾的查询字符串须经过正确的编码。查询字符串中每个参数的名称和值必须使用encodeURIComponent()进行编码，然后放到URL末尾；所有键值对必须由和号 &amp;分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;,&quot;example.php?name1=value1&amp;name2=value2&quot;,true);</span><br></pre></td></tr></table></figure><p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function addURLParam(url,name,value) &#123;</span><br><span class="line">    url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot;);</span><br><span class="line">    url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);</span><br><span class="line">    return url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addURLParam()函数三个参数：要添加的URL、参数的名称和参数的值。首先检查URL是否包含问号（以确定是否已经有参数存在）。若没有，添加一个问号；否则，添加和号。然后将参数名称和值进行编码，添加到URL末尾。最后返回添加参数之后的URL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var url = &quot;example.php&quot;;</span><br><span class="line">//添加参数</span><br><span class="line">url = addURLParam(url,&quot;name&quot;,&quot;Nicholas&quot;);</span><br><span class="line">url = addURLParam(url,&quot;book&quot;,&quot;Professional JavaScript&quot;);</span><br><span class="line">//初始化请求</span><br><span class="line">xhr.open(&quot;get&quot;,url,false);</span><br></pre></td></tr></table></figure></p>
<p></p><h3>POST请求</h3><br>&emsp;&emsp;通常向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主体提交，GET请求传统上不是这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;post&quot;,&quot;example.php&quot;,true);</span><br></pre></td></tr></table></figure><p></p>
<p>发送POST请求的第二步是向send()方法传入数据。</p>
<p></p><h3>XMLHttpRequest2级  FormData</h3><br>&emsp;&emsp;FormData为序列化表单以及创建与表单格式相同的数据提供便利。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = new FormData();</span><br><span class="line">data.append(&quot;name&quot;,&quot;Nicholas&quot;);</span><br></pre></td></tr></table></figure><p></p>
<p>append()接收两个参数：键和值，分别对应表单字段的名字和字段的值。通过向FormData构造函数中传入表单元素，可以用表单元素的数据预先向其中填入键值对。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var data = new FormData(document.form[0]);</span><br></pre></td></tr></table></figure></p>
<p>创建FormData的实例后，将它直接传给XHR的send()方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/23/AJAX/" data-id="cjfeozu620005ssv2kce6iyb3" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JSON" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/23/JSON/" class="article-date">
  <time datetime="2018-03-23T07:48:43.000Z" itemprop="datePublished">2018-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/23/JSON/">JSON</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h2>JSON</h2><br>&emsp;&emsp;JSON，JavaScript Object Notation，JavaScript对象表示法。JSON直接被传给eval()，不必创建对象。<br>&emsp;&emsp;JSON的语法可以表示 简单值(字符串、数值、布尔值和null，不支持undefined)、对象、数组。JSON不支持变量、函数或对象实例。不局限于JavaScript的范畴。<p></p>
<p></p><h2>解析与序列化</h2><br>&emsp;&emsp;JSON相比XML数据结构的解析更方便。<p></p>
<p></p><h3>JSON对象</h3><br>&emsp;&emsp;JSON是JavaScript语法的子集，eval()函数可以解析JSON、解释并返回JavaScript对象和数组。对于不能原生支持JSON解析的浏览器，使用这个shim是最佳选择。JSON对象由两个方法，stringify()和parse()。这两个方法分别用于把JavaScript对象序列化为JSON字符串和把JSON字符串解析为原生JavaScript值。<br><figure class="highlight plain"><figcaption><span>e.g.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">title: &quot;Professional JavaScript&quot;,</span><br><span class="line">authors: [</span><br><span class="line">&quot;Nicholas C. Zakas&quot;</span><br><span class="line">],</span><br><span class="line">edition: 3,</span><br><span class="line">year: 2011</span><br><span class="line">&#125;;</span><br><span class="line">var jsonText = JSON.stringify(book);</span><br><span class="line">console.log(jsonText);  //&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:[&quot;Nicholas C. Zakas&quot;],&quot;edition&quot;:3,&quot;year&quot;:2011&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>&emsp;&emsp;默认情况下，JSON.stringify()输出的JSON字符串不包含任何空格字符或缩进。序列化JavaScript对象时，所有函数及原型对象都会被有意忽略。值为undefined的任何属性也会被跳过。<br><figure class="highlight plain"><figcaption><span>e.g.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">title: &quot;Professional JavaScript&quot;,</span><br><span class="line">authors: [</span><br><span class="line">&quot;Nicholas C. Zakas&quot;</span><br><span class="line">],</span><br><span class="line">edition: 3,</span><br><span class="line">year: 2011</span><br><span class="line">&#125;;</span><br><span class="line">var jsonText = JSON.stringify(book);</span><br><span class="line">var bookCopy = JSON.parse(jsonText);</span><br><span class="line">console.log(bookCopy);  //&#123;title: &quot;Professional JavaScript&quot;, authors: Array(1), edition: 3, year: 2011&#125;</span><br><span class="line">authors:[&quot;Nicholas C. Zakas&quot;]</span><br><span class="line">edition:3</span><br><span class="line">title:&quot;Professional JavaScript&quot;</span><br><span class="line">year:2011</span><br><span class="line">__proto__:Object</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如果传给JSON.stringify()的字符串不是有效的JSON，该方法会报错。</p>
<p></p><h3>序列化选项</h3><br>&emsp;&emsp;JSON.stringify()除了要序列化JavaScript对象外，还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化JavaScript对象。第一个参数是过滤器，可以是一个数组，也可以是函数；第二个参数是选项，表示是否在JSON字符串中保留缩进。<br>1.过滤结果<br>&emsp;&emsp;如果过滤器参数是数组，JSON.stringify()结果中只包含数组中列出的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">&quot;title&quot;: &quot;Professional JavaScript&quot;,</span><br><span class="line">&quot;authors&quot;: [&quot;Nocjolas C. Zakas&quot;],</span><br><span class="line">edition: 3,</span><br><span class="line">year: 2011</span><br><span class="line">&#125;;</span><br><span class="line">var jsonText = JSON.stringify(book,[&quot;title&quot;,&quot;edition&quot;]);</span><br><span class="line">console.log(jsonText);  //&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:3&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>&emsp;&emsp;如果第二个参数是函数，行为稍有不同。传入的函数接受两个参数，属性名和属性值。根据属性名可以知道如何处理要序列化的对象中的属性。属性名只能是字符串，而在值并非是键值对结构的值时，键名可以是空字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">&quot;title&quot;: &quot;Professional JavaScript&quot;,</span><br><span class="line">&quot;authors&quot;: [&quot;Nicjolas C. Zakas&quot;],</span><br><span class="line">edition: 3,</span><br><span class="line">year: 2011</span><br><span class="line">&#125;;</span><br><span class="line">var jsonText = JSON.stringify(book,function(key,value)&#123;</span><br><span class="line">switch(key)&#123;</span><br><span class="line">    case &quot;authors&quot; :</span><br><span class="line">return value.join(&quot;,&quot;)</span><br><span class="line">    case &quot;year&quot; :</span><br><span class="line">return 5000;</span><br><span class="line">    case &quot;edition&quot; :</span><br><span class="line">return undefined;</span><br><span class="line">    default:</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(jsonText);  //&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicjolas C. Zakas&quot;,&quot;year&quot;:5000&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如果键为”authors”,就将数组连接为一个字符串；如果键为”year”,则将其值设为5000；如果键为”edition”,通过返回undefined删除该属性。<strong>最后，一定要提供default项，此时返回传入的值，以便其他值能正常出现在结果中。</strong>要序列化的对象中每一个对象都要经过过滤器，因此数组中的每个带有这些属性的对象经过过滤之后，每个对象都只会包含”title”,”authors”,”year”属性。<br>2.字符串缩进<br>&emsp;&emsp;JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。若参数是一个数值，那它表示的是每个级别缩进的空格数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">&quot;title&quot;: &quot;Professional JavaScript&quot;,</span><br><span class="line">&quot;authors&quot;: [&quot;Nicjolas C. Zakas&quot;],</span><br><span class="line">edition: 3,</span><br><span class="line">year: 2011</span><br><span class="line">&#125;;</span><br><span class="line">var jsonText = JSON.stringify(book,null,4);</span><br><span class="line">console.log(jsonText);  </span><br><span class="line">//</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;: &quot;Professional JavaScript&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &quot;Nicjolas C. Zakas&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;edition&quot;: 3,</span><br><span class="line">    &quot;year&quot;: 2011</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">&quot;title&quot;: &quot;Professional JavaScript&quot;,</span><br><span class="line">&quot;authors&quot;: [&quot;Nicjolas C. Zakas&quot;],</span><br><span class="line">edition: 3,</span><br><span class="line">year: 2011</span><br><span class="line">&#125;;</span><br><span class="line">var jsonText = JSON.stringify(book,null,&quot;--&quot;);</span><br><span class="line">console.log(jsonText);</span><br><span class="line">//</span><br><span class="line">&#123;</span><br><span class="line">--&quot;title&quot;: &quot;Professional JavaScript&quot;,</span><br><span class="line">--&quot;authors&quot;: [</span><br><span class="line">----&quot;Nicjolas C. Zakas&quot;</span><br><span class="line">--],</span><br><span class="line">--&quot;edition&quot;: 3,</span><br><span class="line">--&quot;year&quot;: 2011</span><br><span class="line">&#125;</span><br><span class="line">//缩进字符串最长不能超过10个字符串，长度超过10个，结果只出现前10个字符。</span><br></pre></td></tr></table></figure>
<p>3.toJSON()方法<br>&emsp;&emsp;可以为任何对象添加toJSON()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">&quot;title&quot;: &quot;Professional JavaScript&quot;,</span><br><span class="line">&quot;authors&quot;: [&quot;Nicjolas C. Zakas&quot;],</span><br><span class="line">edition: 3,</span><br><span class="line">year: 2011,</span><br><span class="line">toJSON: function() &#123;</span><br><span class="line">return this.title;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var jsonText = JSON.stringify(book);</span><br><span class="line">console.log(jsonText);  //&quot;Professional JavaScript&quot;</span><br></pre></td></tr></table></figure></p>
<p>假设把一个对象传入JSON.stringify()，序列化该对象的顺序如下。<br>(1) 如果存在toJSON()方法而且能通过它取得有效值，则调用该方法。否则按默认顺序序列化。<br>(2) 如果提供第二个参数，应用这个函数过滤器。<br>(3) 对第(2)步返回的每个值进行相应的序列化<br>(4) 如果提供了 第三个参数，执行相应的格式化。</p>
<p></p><h3>解析选项</h3><br>&emsp;&emsp;JSON.parse()也可以接收另一个参数，参数是函数，将在每个键值对上调用。区别JSON.stringify()接收的替换函数，这个函数被称作还原函数，实际上签名相同。返回undefined，删除相应的键；返回其他值，将值插入到结果中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">&quot;title&quot;: &quot;Professional JavaScript&quot;,</span><br><span class="line">&quot;authors&quot;: [&quot;Nicjolas C. Zakas&quot;],</span><br><span class="line">edition: 3,</span><br><span class="line">year: 2011,</span><br><span class="line">releaseDate: new Date(2011,11,1)</span><br><span class="line">&#125;;</span><br><span class="line">var jsonText = JSON.stringify(book);</span><br><span class="line">var bookCopy = JSON.parse(jsonText,function(key,value) &#123;</span><br><span class="line">if(key == &quot;releaseDate&quot;) &#123;</span><br><span class="line">return new Date(value);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(bookCopy.releaseDate.getFullYear());  //2011</span><br></pre></td></tr></table></figure><p></p>
<p>先为book对象新增了一个releaseDate属性，该属性保存着一个Date对象。经过序列化之后变成了有效的JSON字符串，然后经过解析又在bookCopy中还原为一个Date对象。还原函数遇到”releaseDate”键时，会基于相应的值创建一个新的Date对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/23/JSON/" data-id="cjfeozu6h000bssv2qylwo246" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/23/闭包/" class="article-date">
  <time datetime="2018-03-23T04:28:37.000Z" itemprop="datePublished">2018-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/23/闭包/">闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h2>闭包是指有权访问另一个函数作用域中的变量的函数</h2><br>&emsp;&emsp;创建闭包的常见方式，是在一个函数内部创建另一个函数。<p></p>
<p></p><h2>作用域</h2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i =0;i &lt; 10; i++) &#123;</span><br><span class="line">&#125;</span><br><span class="line">alert(i);  //10</span><br></pre></td></tr></table></figure><p></p>
<p></p><h3>作用域链</h3><br>&emsp;&emsp;1.声明变量：使用var声明的变量会自动被添加到最接近的环境中。；在with语句中，最接近的环境是函数环境。若初始化变量时没有使用var声明，该变量自动被添加到全局环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(num1,num2) &#123;</span><br><span class="line">var sum = num1 + num2;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">var result = add(10,20);</span><br><span class="line">alert(sum);  //Uncaught ReferenceError: sum is not defined 由于sum不是有效变量，会导致错误</span><br></pre></td></tr></table></figure><p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(num1,num2) &#123;</span><br><span class="line">sum = num1 + num2;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">var result = add(10,20);</span><br><span class="line">alert(sum); //30:当调用完add()之后，添加到全局环境的变量sum将继续存在；即使函数执行完毕，后面的代码依旧可以访问。</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2.查询标识符：当在某个环境为了读取或写入而引用另一个标识符时，必须通过搜索来确定标识符世纪代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var color = &quot;blue&quot;;</span><br><span class="line">function getColor() &#123;</span><br><span class="line">return color;</span><br><span class="line">&#125;</span><br><span class="line">alert(getColor()); //blue</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var color = &quot;blue&quot;;</span><br><span class="line">function getColor() &#123;</span><br><span class="line">var color = &quot;red&quot;;</span><br><span class="line">return color;</span><br><span class="line">&#125;</span><br><span class="line">alert(getColor()); //red</span><br></pre></td></tr></table></figure>
<p></p><h3>闭包与变量</h3><br>&emsp;&emsp;闭包只能取得包含函数中任何变量的最后一个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions() &#123;</span><br><span class="line">var result = new Array();</span><br><span class="line">for(var i = 0;i &lt; 10;i++)&#123;</span><br><span class="line">result[i] = function() &#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;  //每个函数都返回10</span><br></pre></td></tr></table></figure><p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions() &#123;</span><br><span class="line">var result = new Array();</span><br><span class="line">for(var i = 0;i &lt; 10;i++)&#123;</span><br><span class="line">result[i] = function(num) &#123; //匿名函数强制闭包</span><br><span class="line">return function()&#123;</span><br><span class="line">return num;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;(i);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p><h3>关于this对象</h3><br>&emsp;&emsp;this对象在运行时基于函数的执行环境绑定：全局函数中，this等于window，当函数被当作某个对象的方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，因此this对象通常指向window。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">name: &quot;My Object&quot;,</span><br><span class="line">getNameFunc:function() &#123;</span><br><span class="line">return function()&#123;</span><br><span class="line">return this.name;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); //&quot;The Window&quot;</span><br></pre></td></tr></table></figure><p></p>
<p>getNameFunc()方法返回匿名函数，匿名函数返回this.name.由于getNameFunc()返回一个函数，因此调用object.getNameFunc()会立即调用它返回的函数，结果返回字符串。</p>
<p></p><h3>内存泄漏</h3><br>&emsp;&emsp;如果闭包的作用域中<strong>保存</strong>着一个HTML元素，意味着该元素无法被销毁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function assignHandler() &#123;</span><br><span class="line">var element = document.getElementById(&quot;someElement&quot;);</span><br><span class="line">element.onclick = function() &#123;</span><br><span class="line">alert(element.id);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function assignHandler() &#123;</span><br><span class="line">var element = document.getElementById(&quot;someElement&quot;);</span><br><span class="line">var id = element.id; //把element.id的一个副本保存在一个变量中，在闭包中引用该变量删除循环引用</span><br><span class="line">element.onclick = function() &#123;</span><br><span class="line">alert(id);</span><br><span class="line">&#125;;</span><br><span class="line">element = null;  //解除对DOM对象的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p><h3>私有变量</h3><br>&emsp;&emsp;任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。有权访问私有变量和私有函数的公有方法称为特权方法。方法一在构造函数中定义特权方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function MyObject() &#123;</span><br><span class="line">    //私有变量和私有函数</span><br><span class="line">var privateVariable = 20;</span><br><span class="line">function privateFunction() &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">//特权方法</span><br><span class="line">this.publicMethod = function() &#123;</span><br><span class="line">privateVariable++;</span><br><span class="line">return privateFunction();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>&emsp;&emsp;可以使用构造函数模式、原型模式来实现自定义的特权方法，也可以使用模块模式、增强的模块模式实现单例的特权方法。<br>&emsp;&emsp;过度使用闭包会占用大量内存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/23/闭包/" data-id="cjfeozu88002pssv2o7ut9w9d" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-递归" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/23/递归/" class="article-date">
  <time datetime="2018-03-23T02:41:17.000Z" itemprop="datePublished">2018-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/23/递归/">递归</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h1>1.递归函数是在一个函数通过名字调用自身的情况下构成的。</h1><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num) &#123;</span><br><span class="line">if(num &lt;= 1)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return num * factorial(num-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var anotherFactorial = factorial;</span><br><span class="line">factorial = null;</span><br><span class="line">alert(anotherFactorial(4));  //Uncaught TypeError: factorial is not a function</span><br></pre></td></tr></table></figure><p></p>
<p></p><h2>arguments.callee是一个指向正在执行的函数的指针，可以用它实现对函数的递归调用。</h2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num) &#123;</span><br><span class="line">if(num &lt;= 1)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return num * arguments.callee(num-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var anotherFactorial = factorial;</span><br><span class="line">factorial = null;</span><br><span class="line">alert(anotherFactorial(4)); //24</span><br></pre></td></tr></table></figure><p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/23/递归/" data-id="cjfeozu88002nssv28mes6twc" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery类库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/18/jQuery类库/" class="article-date">
  <time datetime="2018-03-18T07:18:54.000Z" itemprop="datePublished">2018-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/18/jQuery类库/">jQuery类库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>////jQuery基础<br>jQuery类库定义了一个全局函数:jQuery()，快捷别名$.<br>e.g. var divs = $(“div”); 返回的值表示零个或多个DOM元素，这就是jQuery对象。 jQuery()是工厂函数，不是构造函数，返回一个新创建的对象。<br>////jQuery()函数<br>1、传递CSS选择器(字符串)给$()方法。<br>2、传递一个Element、Document或Window对象给$()方法。被封装成jQuery对象并返回。<br>3、传递HTML文本字符串给$()方法。$()接受可选的第二参数，可以传递Document对象来指定与所创建元素相关联的文档。<br>4、传入一个函数给$()方法。传给jQuery()的函数在被调用时，this指向document对象，唯一的参数指向jQuery函数。<br>////查询与查询结果 $()的返回值是一个jQuery对象，是类数组。<br>e.g. $(“body”).length  //=&gt;1:文档只有唯一一个body元素<br>     $(“body”)[0]   //等于document.body<br>     selector属性是创建jQuery对象时的选择器字符串。context属性是上下文对象，是传递给$()方法的第二参数，默认Document对象。所有jQuery对象都有一个名为jQuery的属性。<br>////想要遍历jQuery对象中的元素时，可以调用each()方法来代替for()循环。但是如果回调函数在任一元素上返回false，遍历在该元素后中止。jQuery的map()方法和Array.prototype.map()方法很接近。元素作为this值和第二参数传入，元素的索引值作为第一参数传入。另一个基础方法是index()。接受一个元素作为参数，返回值是该元素在此jQuery对象中的索引值，找不到返回-1。is()方法接受一个选择器作为参数，如果选中元素中至少有一个匹配该选择器时返回true。<br>jQuery中的getter和setter<br>//获取和设置HTML属性 attr()方法是jQuery中用于HTML属性的setter和getter。处理浏览器的兼容性和一些特殊情况，还让HTML属性名和JavaScript属性名可以等同使用。removeAttr()可用来从所有选中元素中移除某个属性。<br>e.g. $(“form”).attr(“action”);  //获取第一个form元素的action属性<br>     $(“#icon”).attr(“src”,”icon.gif”);  //设置src属性<br>     $(“#banner”).attr({  //一次设置4个属性<br>         src: “banner.gif”,<br>         alt: “Advertisement”,<br>         width: 720, height: 64<br>     });<br>     $(“a”).attr(“target”,”_blank”);  //使所有链接在新窗口中打开<br>     $(“a”).attr(“target”,function() {  //使站内链接在本窗口中打开，并且让<br>         if(this.host == location.host)<br>         return “_self”<br>         else return “_blank”;  //非站内链接在新窗口打开<br>     });<br>     $(“a”).attr({target: function() {  //可以像这样传入函数<br>         …<br>     }});<br>     $(“a”).removeAttr(“target”);  //让所有链接在本窗口中打开<br>//获取和设置CSS属性 css()方法和attr()方法类似，只是css()方法作用于元素的CSS样式，非HTML属性。返回的值是元素的当前样式，不能获取复合样式的值。<br>e.g. $(“h1”).css(“font-weight”);  //获取第一个 h1 的字体重量<br>     $(“h1”).css(“fontWeight”);  //也可采用驼峰格式<br>     $(“h1”).css(“font”);  //错误，不可获取复合样式<br>     $(“h1”).css(“font-variant”,”smallcaps”);  //将样式设置在所有 h1 元素上<br>     $(“div.note”).css(“border”,”solid black 2px”);  //设置复合样式是OK的<br>     $(“h1”).css({<br>         backgroundColor: “black”,<br>         textColor: “white”,<br>         fontVariant: “small-caps”,<br>         padding: “10px 2px 4px 20px”,<br>         border: “dotted black 4px”<br>     });  //一次设置多个样式<br>     $(“h1”).css(“font-size”,function(i,curval) {<br>         return Math.round(1.25 * parseInt(curval));<br>     });  //让所有 h1 的字体大小增加 25%<br>//获取和设置CSS类 addClass()从选中元素添加类 removeClass()删除类 toggleClass()当元素没有某些类时，给元素添加类，反之则删除。hasClass()判断类是否存在，只能接受单个类名作为参数，并且不支持函数参数。<br>e.g. // 添加CSS类<br>     $(“h1”).addClass(“hilite”); //给所有 h1 元素添加一个类<br>     $(“h1+p”).addClass(“hilite first”); //给 h1 后面的 p 添加两个类<br>//获取和设置HTML表单值 val()方法来设置和获取HTML表单元素的value属性，还可用于获取和设置复选框、单选按钮以及 select 元素的选中状态。<br>e.g. $(“#surname”).val();  //获取surname文本域的值<br>     $(“input:radio[name=ship]:checked”).val();  //获取选中的单选按钮的值。<br>     $(“input:checkbox”).val([“opt1”,”opt2”]);  //选中带有这些名字或值的复选框<br>//设置和获取元素内容 text()和html()方法用来获取和设置元素的纯文本或HTML内容。不带参数调用时，text()返回所有匹配元素的所有子孙文本节点的纯文本内容，html()返回第一个匹配元素的HTML内容。传入字符串给text()或html()，该字符串会用作该元素的纯文本或格式化的HTML文本内容，替换掉所有存在的内容。<br>e.g. var title = $(“head title”).text();  //获取文档标题<br>     var headline = $(“h1”).html();  //获取第一个 h1 元素的html<br>     $(“h1”).text(function(n,current){  //给每个标题添加章节号<br>         return “#” + (n+1) + “: “ + current<br>     });</p>
<p>/<br>/<br>/<br>/<br>////jQuery中的Ajax<br>//使用HTTP脚本按需加载数据，而不需要刷新整个页面。jQuery定义了一个高级工具方法和四个高级工具函数，这些工具都基于jQuery.ajax()。<br>//load()方法，向它传入一个url，它会异步加载该url的内容，然后将内容插入每一个选中元素中，替换掉已存在的任何内容。<br>e.g.  setInterval(function(){<br>    $(‘#status’).load(“status_report.html”);<br>},6000);<br>只想显示被加载文档的一部分，可以在URL后面添加一个空格和一个jQuery选择器。当URL加载完成后，jQuery会用指定的选择器来从加载好的html中选取需要显示的部分。<br>e.g.  $(‘#temp’).load(“wheater_report.html #temperature”);<br>除了必须的URL参数，load()方法接受两个可选参数。第一个可选参数表示的数据，可以追加到URL后面，或者与请求一起发送。传入的是字符串，则会追加到URL后面(放在”?”或”&amp;”后面)。传入对象，该对象会被转换成一个用”&amp;”分隔的键值对后与请求一起发送。通常情况下，load()方法发送HTTP GET请求，传入数据对象发送POST请求。<br>e.g.  $(‘#temp’).load(“us_weather_report.html”,”zipcode=01234”); //加载特定区号的天气预报<br>      $(‘#temp’).load(“us_weather_report.html”,{ zipcode: 01234,units: ‘f’});  //使用对象作为数据，并指定为华氏温度<br>load()方法的另一个可选参数是回调函数。当Ajax请求成功或未成功，以及(当请求成功时)URL加载完毕并插入选中元素时，会调用该回调函数。未指定任何数据下，回调函数作为第二个参数传入。否则必须是第三个参数。jQuery对象每一个元素上都会调用回调函数，并且每次调用都会调用都会传入三个参数：被加载URL的完整文本内容、状态码字符串，以及用来记载URL的XMLHttpRequest对象。状态码是jQuery的，类似”success”、”error”、”timeout”.<br>//Ajax工具函数 jQuery的其他Ajax高级工具是函数非方法，可通过jQuery或$直接调用。<br>1、jQuery.getScript() 第一个参数是JavaScript代码文件的URL。异步加载文档，加载完成后再全局作用域执行代码。适用于同源和跨源脚本。<br>e.g.  jQuery.getScript(“<a href="http://example.com/js/widget.js&quot;)" target="_blank" rel="noopener">http://example.com/js/widget.js&quot;)</a>;<br>可以传入回调函数作为第二参数，jQuery会在代码加载和执行完成后调用一次该回调函数。<br>e.g.  //加载一个类库，并在加载完成时立刻使用它<br>     jQuery.getScript(“js/jquery.my_plugin.js”,function() {<br>     $(‘div’).my_plugin();  //使用加载的类库<br>    });<br>jQuery.getScript()通常会使用XMLHttpRequest对象获取执行的脚本内容。跨域请求，jQuery使用 script 加载脚本。同源下，回调函数第一个参数是脚本的文本内容，第二参数是”success”状态码，第三参数是用来获取脚本内容的XMLHttpRequest对象，jquery.getScript()函数的返回值也是XMLHttpRequest对象。跨源，不存在XMLHttpRequest对象，无法获取脚本内容。回调函数第一参数和第三参数是undefined,jQuery.getScript()的返回值也是undefined.<br>传递给jQuery.getScript()回调函数在请求成功时才被调用。若需要在发生错误和成功时得到通知则需要底层jQuery.ajax()函数。<br>2、jQuery.getJSON() 获取文本特殊处理，调用指定的回调函数。jQuery.getJSON()获取到文本后解析为JSON。此方法在传入了回调函数时才有用。成功加载URL将内容成功解析成JSON后，解析结果会作为第一个参数传入回调函数中。与jquery.getScript()一样回调函数的第二个和第三个参数是”success”状态码和XMLHttpRequest对象。<br>e.g.  //假设data.json包含文本: ‘{“x”:1,”y”:2}’<br>      jQuery.getJSON(“data.json”,function(data){<br>          //data参数是对象{x:1,y:2}<br>})<br>该方法接受一可选的数据对象参数，和load()方法一样。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/18/jQuery类库/" data-id="cjfeozu88002mssv2w5h5y5xx" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-脚本化文档" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/脚本化文档/" class="article-date">
  <time datetime="2018-03-17T07:41:44.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/脚本化文档/">脚本化文档</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通过id选取元素：document.getElementsById() id属性必须唯一<br>通过名字选取元素：document.getElementsByName() name属性不必唯一，该方法定义在HTMLDocument类中，而不在Document类中，所以只针对HTML文档可用，在xml文档中不可用。返回nodeList集合，只在少数DOM元素中有效。<strong>在IE中该方法也返回id属性匹配指定值的元素。</strong><br>通过标签名选取元素：document.getElementsByTagName() 返回nodeList集合<br>e.g. 查找文档中第一个 p 元素里面的所有 span 元素<br>     var firstpara = document.getElementsByTagName(“p”)[0];<br>     var firstParaSpans = firstpara.getElementsByTagName(“span”);<br>e.g. 引用命名(或有ID的)表单<br>     document.form.shipping_address;<br>通过CSS类选取元素：document.getElementsByClassName()<br>返回nodeList集合，只能选取调用该方法的元素的后代元素。IE8及其以下版本的浏览器未实现。<br>通过CSS选择器选取元素：可以通过ID、名字、标签名、类名选取元素。document.querySelectorAll(“selector”) 返回值是nodeLIst集合 IE8及其以下版本的浏览器只支持CSS2标准的选择器语法。<br>document.all[]表示所有文档中的元素，除了Text节点。<br>////文档结构和遍历<br>parentNode 该节点的父节点 Document没有父节点<br>childNode 只读的类数组对象(NodeList对象)<br>firstChild、lastChild 该节点的第一个和最后一个，没有子节点则null<br>nextSibling、previoursSibling该节点的兄弟节点中的前一个和下一个。具有相同父节点的两个节点为兄弟节点。顺序反映了在文档中的出现顺序。<br>nodeType 节点类型。9代表Document节点，1代表Element节点，3代表Text节点，8代表Comment节点，11代表DocumentFragment节点。<br>nodeValue Text节点或Comment节点的文本内容<br>nodeName 元素的标签名，以大写形式表示。<br>////作为元素树的文档<br>API第一部分是Element对象的children属性。NodeList对象，但只包含Element对象。Text和Comment节点没有children属性，上述Node.parentNode属性不可能返回Text或Comment节点。<br>基于元素的文档遍历api第二部分是Element属性。<br>////属性<br>HTMLElement定义了通用的HTTP属性(id、标题lang和dir)属性，以及事件处理程序属性(onclick)。HTML属性名不区分大小写，从HTML属性名转到JavaScript属性名应小写。属性名不止一个单词则除首单词以外的单词首字母大写。HTML属性名在JavaScript中是保留字则在属性名前加html。<br>////设置和获取非标准的HTML属性<br>getAttribute()和setAttribute()方法，查询和设置非标准的HTML属性。Element属性还设置了hasAttribute()检测属性是否存在，removeAttribute()删除属性。<br>////元素的内容<br>查询纯文本形式的元素内容，或在文档中插入纯文本。作为纯文本的元素内容 Node的textContent属性<br>e.g. var para = document.getElementByTagName(“p”)[0];<br>     var text = para.textContent;<br>     para.textContent = “Hello World!”;<br>作为Text节点的元素内容<br>e.g. 查找元素的后代中节点的所有Text节点】】<br>    function textContent(e) {<br>    var child,type,s = “”;<br>    for(child = e.firstChild;child != null; child = child.nextSibling){<br>        type = child.nodeType;<br>        if(type === 3 || type === 4 )<br>        s += child.nodeValue;<br>        else if (type === 1)<br>        s += textConetent(child);<br>    }<br>    return s;<br>}<br>////创建、插入和删除节点<br>创建节点 text节点 var newnode = document.createTextNode(“text node content”);<br>每个节点有一个cloneNode()方法返回该节点的一个全新副本。参数true能递归的复制所有后代节点，false执行浅复制。<br>插入节点 appendChild()(插入的节点使其成为那个节点的最后一个子节点)或insertBefore()(接受两个参数 1待插入的节点2已存在的节点)<br>删除和替换节点 removeChild()从文档树删除一个节点，在其父节点上调用，并将需要删除的子节点作为方法参数传递(两个参数1新节点2需要代替的节点)。n.parentNode.removeChild(n);</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/17/脚本化文档/" data-id="cjfeozu88002rssv2vu7lcf6n" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浏览器中的JavaScript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/浏览器中的JavaScript/" class="article-date">
  <time datetime="2018-03-17T02:34:53.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/浏览器中的JavaScript/">浏览器中的JavaScript</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>////Window、Document和Element对象事件处理程序相关。在脚本中绑定函数，事件发生时异步调用。事件处理程序属性名以单词’on’开始。<br>////WEB文档里的JavaScript 内容、呈现和行为的组合，叫做动态HTML或DHTML。文档里应少量食用JavaScript。<br>////WEB应用里的JavaScript WEB应用从服务器获取新信息，不用重新载入界面称为AJAXA应用。代码和文档来自不同的源 有重要的安全隐患。<br>////javascript:URL能识别的资源是转换成字符串的执行代码的返回值。alert返回undefined.JavaScript:URL在文档之外确实有重要角色，但应该避免在HTML中使用。<br>/////JavaScript:URL应用:书签<br>////客户端JavaScript线程模型：严格的单线程，HTML5定义了一个并发控制方式WEB WORKER：执行计算密集任务而不冻结用户界面的后台线程。<br>。<br>////兼容性和互用性<br>/////检测渲染模式document.compatMode,值为”CSS1Compat”标准模式，值为”BackCompat”或undefined则为怪异模式。<br>////IE里的条件注释<br>/////   /<em>@cc_on<br>          @</em>/<br>////可访问性<br>/////应该尽可能支持独立于设备的事件<br>////安全性<br>/////JavaScript不支持某些功能。例如不能删除数据或植入病毒。<br>/////在自己支持的某些功能上施加限制。<br>////同源策略 脚本只能读取和所属文档来源相同的窗口和文档的属性，文档的来源包括协议、主机，以及载入文档的URL端口。<br>////不严格的同源策略<br>/////1.document.domain属性设置为一个源<br>/////2.跨域资源共享：允许服务器用头信息显式地列出源，或使用通配符匹配所有源并允许由任何地址请求文件。<br>/////3.跨文档消息：允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本。调用Window对象上的postMessage()方法，可以异步传递消息事件到窗口的文档里。<br>////跨站脚本<br>/////防止XSS攻击的方式是，在使用任何不可信的数据来动态的创建文档内容之前，从中移除HTML标签。<br>     e.g. name = name.replace(/&lt;/g,”&lt;”).replace(/&gt;/g,”&gt;”);<br>     html5为iframe元素定义了sandbox属性，在实现之后，允许显示不可信内容并自动禁用脚本。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/17/浏览器中的JavaScript/" data-id="cjfeozu7s001qssv2eve0bshh" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript函数4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/JavaScript函数4/" class="article-date">
  <time datetime="2018-03-17T02:28:09.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/JavaScript函数4/">JavaScript函数4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>///函数属性、方法和构造函数<br>   length属性 arguments.length表示传入函数的实参的个数。函数的length属性只读，代表函数实参的数量，参数指的是形参而非实参，就是函数定义时给出的实参个数。<br>   prototype属性 每个函数都包含一个prototype属性，指向一个对象的引用，原型对象。将函数用作构造函数时，新创建的对象会从原型对象继承属性。<br>   call()和apply()方法 看作某个对象的方法，通过调用方法的形式间接调用。call()和apply()方法的第一个实参调用函数的母对象，调用上下文，在函数体内通过this获得对它的引用。继承自function.prototype<br>   e.g. f.call(o);<br>        f.apply(o); //以对象o的方法调用函数f()<br>    call() 第一个参数是指定函数内部中this的指向(函数执行时所在作用域)，第二个参数是函数调用时需要传递的参数。可以指定该函数内部this的指向，即函数执行时所在的作用域，然后在所指定的作用域中，调用该函数，并且会立即执行该函数。e.g. f.call(0,1,2)<br>    e.g. var keith = {<br>        rascal: 123<br>    };<br>         var rascal = 456;<br>         function a() {<br>             console.log(this.rascal);<br>         }<br>         a();  //456<br>         a.call(); //456<br>         a.call(null); //456<br>         a.call(undefined); //456<br>         a.call(this); //456:以上作用域均为a()函数<br>         a.call(keith); //123：作用域keith对象<br>    e.g. function keith(a,b) {<br>        console.log(a + b);<br>    }<br>    keith.call(null,1,2); //3:第一个参数为null，undefined，this表明函数此时处于全局作用域。apply必须以数组的形式添加。<br>bind()方法 用于指定函数内部的this指向(执行时所在的作用域)，然后返回一个新函数。传递参数时和call()方法相同。<br>toString()方法 返回字符串<br>Function()构造函数 该函数创建的函数并不是使用词法作用域，函数体代码的编译总是会在顶层函数执行。<br>e.g. var scope = “global”;<br>     function constructFunction() {<br>         var scope = “local”;<br>         return new Function (“return scope”); //无法捕获局部作用域<br>     }<br>     //因为通过Function()构造函数<br>     //所返回的函数使用的不是局部作用域<br>     constructFunction()(); //=&gt;”global”<br>可调用对象 RegExp对象<br>////函数式编程<br>高阶函数：接受一个或多个函数作为参数返回一个新函数。<br>不完全函数：把一次完整的函数调用拆成多次函数调用，每次传入的参数都是完整实参的一部分。<br>记忆：memorize()函数创建一个新对象，这个对象被当做缓存并赋值给一个局部变量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/17/JavaScript函数4/" data-id="cjfeozu7c000yssv21h3xfvcs" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript函数3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/JavaScript函数3/" class="article-date">
  <time datetime="2018-03-17T02:27:00.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/JavaScript函数3/">JavaScript函数3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>////闭包<br>    JavaScript也采用词法作用域，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内。<br>    作用域<br>    e.g. var scope = “global”;<br>         function f() {<br>             console.log(scope); //输出undefined:局部变量在整个函数体始终有定义，局部变量遮盖同名全局变量<br>             var scope = “local”; //变量在这里赋值，但变量本身在函数体内任何地方都有定义<br>             console.log(scope); //输出local<br>         }<br>         var scope = ‘global’;<br>          function fn() {<br>          alert(scope); //未定义直接赋值的变量自动声明为全局作用域，所以上例不适用，这里的scope就是global<br>          scope = ‘local’; //更改了全局变量scope值变为local<br>          alert(scope); //local<br>         }<br>        fn();<br>        alert(scope);//local</p>
<pre><code>var scope = &apos;global&apos;;
function fn(scope) { //scope此时是函数的参数
alert(scope); //为被初始化
scope = &apos;local&apos;; //局部变量
alert(scope);
}
fn();
alert(scope); //全局变量
</code></pre><p><strong>不使用var保留字声明变量, 变量提升为全局变量, 而不论变量处于哪种作用域;<br>如果不使用var声明, 该变量便可配置, 即可被 delete 保留字删除, 删除后该变量便不可访问; 如果使用var声明, 该变量便不可配置, 即不能被 delete 保留字删除;<br>只要是全局变量都可以直接访问, 也可使用 “window.变量名” 来访问, 不管该变量是不是通过var来声明的;</strong><br><strong>闭包 // 如果一个函数访问了它的外部变量，那么它就是闭包。当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。</strong><br>        闭包 e.g. var scope = “global scope”;<br>                 function checkscope() {<br>                 var scope = “local scope”;<br>                 function f() {return scope;}<br>                 return f();<br>                }<br>                checkscope(); //“local scope”</p>
<pre><code>        var scope = &quot;global scope&quot;;
        function checkscope() {
        var scope = &quot;local scope&quot;;
        function f() {return scope;}
        return f;
        }
        checkscope()(); //&quot;local scope&quot;
e.g. function foo(x) {
    var temp = 3;
    function bar(y) {
        alert(x + y + (++temp));
    }
    bar(10);
}
foo(2); //16:非闭包
e.g. function foo(x) {
    var temp = 3;
    return function (y) {
        alert(x + y + (++temp));
    }
}
var bar = foo(2);
bar(10); //16:闭包
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/17/JavaScript函数3/" data-id="cjfeozu6x000qssv27iuhleqq" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript笔记/">JavaScript笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/">HTML/CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript笔记/">JavaScript笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bootstrap/">bootstrap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开始/">开始</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日志/">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简介/">简介</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/HTML/" style="font-size: 12.5px;">HTML</a> <a href="/tags/HTML-CSS/" style="font-size: 15px;">HTML/CSS</a> <a href="/tags/JavaScript/" style="font-size: 17.5px;">JavaScript</a> <a href="/tags/JavaScript笔记/" style="font-size: 10px;">JavaScript笔记</a> <a href="/tags/bootstrap/" style="font-size: 10px;">bootstrap</a> <a href="/tags/开始/" style="font-size: 10px;">开始</a> <a href="/tags/日志/" style="font-size: 20px;">日志</a> <a href="/tags/简介/" style="font-size: 10px;">简介</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/30/JavaScript权威指南1/">JavaScript权威指南1</a>
          </li>
        
          <li>
            <a href="/2018/03/28/ECMAScript6/">ECMAScript6</a>
          </li>
        
          <li>
            <a href="/2018/03/27/圣杯布局/">圣杯布局</a>
          </li>
        
          <li>
            <a href="/2018/03/26/DOM进阶1/">DOM进阶1</a>
          </li>
        
          <li>
            <a href="/2018/03/26/JavaScript练习/">JavaScript练习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>