<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JavaScript函数1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/JavaScript函数1/" class="article-date">
  <time datetime="2018-03-17T02:26:26.000Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/17/JavaScript函数1/">JavaScript函数1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>////函数调用：<br>    1.普通函数调用 printprops({x:1});<br>    2.方法调用 o.m = f;//函数f，对象o，m()方法<br>    <strong>关键字this没有作用域限制，嵌套的函数不会从调用它的函数中继承this。如果嵌套函数作为方法调用，其this的值指向调用它的对象。如果嵌套函数作为函数调用，其this不是全局对象就是undefined。</strong><br>    全局对象：<br>    全局作用域下，this指向全局对象。浏览器中全局对象就是window对象。<br>    e.g. function test(){<br>        return this;<br>    }<br>    test(); //window{}:this关键字没有处于一个声明的对象内部，默认指向全局window对象。<br>    声明的对象：<br>    当this关键字在一个声明对象内部使用，其值会被绑定到该this的函数的最近的父对象。<br>    e.g. var person = {<br>        first : ‘John’,<br>        last : ‘Smith’,<br>        full: function() {<br>            console.log(this.first + ‘ ‘ + this.last);<br>        }<br>        };<br>        person.full(); //在被声明的对象person中的full函数使用this，那么调用this的full函数的最近的父对象就是person，因此，this指向person。<br>        var person = {<br>            first : ‘John’,<br>            last : ‘Smith’,<br>            full: function() {<br>                console.log(this.first + ‘ ‘ + this.last);<br>            },<br>            personTwo : {<br>                first : ‘Allison’,<br>                last : ‘Jones’,<br>                full : function() {<br>                    console.log(this.first + ‘ ‘ + this.last);<br>                }<br>            }<br>        };<br>        person.full(); //John Smith<br>        person.personTwo.full(); //Allison Jones:调用this的full函数最近的父对象是personTwo，this指向personTwo。<br>    当使用new关键字构建一个新的对象，this会绑定到这个新对象。<br>    e.g. function Car(make,model) {<br>        this.make = make;<br>        this.model = model;<br>    };<br>    var myCar = new Car(‘Ford’,’Escape’);<br>    console.log(myCar); //Car {make: “Ford”, model: “Escape”}:使用new关键字来声明一个新的变量，Car函数中的this将会绑定一个新的空对象，然后初始化this.make和this.model的值。<br>    3.构造函数调用<br>    函数或方法调用之前带有关键字new，就构成构造函数调用。<br>    4.间接调用<br>    call() apply()方法间接调用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/17/JavaScript函数1/" data-id="cjf521e7e000zwkv25k7sn0hr" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript数组3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/14/JavaScript数组3/" class="article-date">
  <time datetime="2018-03-14T11:04:49.000Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/14/JavaScript数组3/">JavaScript数组3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ECMAScript5中的数组方法： <br><br>////forEach()从头到尾遍历数组没有break语句 提前终止需要将语句放到try块中，并抛出异常。<br>////map()将每个元素传递给制定函数返回<strong>新</strong>数组包含返回值。<br>e.g. a = [1,2,3];<br>     b = a.map(function(x){<br>         return x*x;<br>     }); // b [1,4,9]<br>////filter()调用数组的子集<br>e.g. a = [5,4,3,2,1];<br>    smallvalues = a.filter(function(x){<br>        return x &lt; 3;<br>    }); //[2,1]<br>    everyother = a.filter(function(x,i){ //x为数组元素，i是元素的索引<br>        return i%2 == 0;<br>    }); //[5,3,1]<br>////every()方法针对所有元素调用判定函数都返回true时返回true。<br>    some()方法存在即true。<br>////reduce()方法两个参数，第一个参数是执行化简的函数，第二个参数(可选)是传递给函数的初始值。<br>////reduceRight()方法工作原理与reduce()相同，不同的是按照数组索引从高到低处理。<br>////indexOf()搜索整个数组具有给定值返回找到的第一个元素的索引或没找到返回-1.indexOf()从头至尾，lastIndexOf()反向。不接收函数作为参数。<br>////Array.isArray([]); //=&gt; true</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/14/JavaScript数组3/" data-id="cjf521e8l001bwkv2yvilhcfz" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript数组2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/14/JavaScript数组2/" class="article-date">
  <time datetime="2018-03-14T11:04:32.000Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/14/JavaScript数组2/">JavaScript数组2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数组方法： <br><br>////join()方法将数组中所有元素转换为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串分割数组的各个元素。Array.join()方法是String.split()方法的逆向操作。<br>e.g. var a = [1,2,3];<br>     a.join(); //“1,2,3”<br>     a.join(“ “); //“1 2 3”<br>     a.join(“”); //“123”<br>     var b = new Array(10);<br>     b.join(‘-‘); //‘———‘<br>////reverse()方法将数组中的元素颠倒顺序返回逆序的数组。替换<br>e.g. var a = [1,2,3];<br>     a.reverse().join(); //=&gt;”3,2,1”,现在的a是[3,2,1]<br>////sort()方法将数组中的元素排列并返回排列后的数组,不带参数调用该方法时以字母表顺序排序<br>e.g. var a = new Array(“bananan”,”apple”,”cherry”);<br>     a.sort();<br>     var s = a.join(“, “);<br>     console.log(s); //apple, bananan, cherry若包含undefined元素会被排到数组尾部<br>     为了按照其他方法而非字母表顺序排列 ，sort()方法传递一个比较函数。第一个参数在前，比较函数返回值小于0.<br>////concat()方法创建并返回一个新数组，元素包括调用concat()的原始数组的元素和concat()的每个参数。<br>e.g. var a = [1,2,3];<br>     a.concat(4,5); //[1,2,3,4,5]<br>     a.concat([4,5]); //[1,2,3,4,5]<br>     a.concat([4,5],[6,7]); //[1,2,3,4,5,6,7]<br>     a.concat(4,[5,[6,7]]); //[1,2,3,4,5,[6,7]]<br>////slice()方法返回指定数组的一个片段或子数组。返回的数组包含第一个参数指定的位置和所有到但不含第二个参数指定的位置之间的所有数组元素。<br>e.g. var a = [1,2,3,4,5]<br>     a.slice(1,-1); //[2,3,4]负数表示倒数第几个元素<br>////splice()方法在数组中插入或删除元素的通用方法。会更改调用的数组。<br>第一个参数指定插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除元素的个数。若被省略，从起始点到数组结尾的所有元素都被删除。返回被删除的元素。<br>e.g. var a = [1,2,3,4,5,6,7,8];<br>     a.splice(4); //返回[5,6,7,8],a是[1,2,3,4]<br>     a.splice(1,2); //返回[2,3],a是[1,4]<br>     a.splice(1,1); //返回[4],a是[1]<br>    前两个参数指定需要删除的数组元素，紧随其后的任意个数的参数指定插入到数组中的元素，从第一个参数指定的位置开始插入。<br>e.g. var a = [1,2,3,4,5];<br>     a.splice(2,0,’a’,’b’); //返回[];a是[1,2,’a’,’b’,3,4,5]<br>     a.splice(2,2,[1,2],3); //返回[‘a’,’b’];a是[1,2,[1,2],3,3,4,5]<br>toString()和toLocaleString()方法： <br><br>////toString()：每个元素转化为字符串，输出带逗号分隔的字符串列表，不包括分隔符。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/14/JavaScript数组2/" data-id="cjf521e8a0017wkv233znao7t" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript数组1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/14/JavaScript数组1/" class="article-date">
  <time datetime="2018-03-14T11:04:18.000Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/14/JavaScript数组1/">JavaScript数组1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数组元素的读写： <br><br>////可以使用附属或非整数来索引数组。此情况，数值转换为字符串，字符串作为属性名使用。只能被当作常规的对象属性，而非数组的索引。若凑巧使用了非负整数的字符串，当作数组索引非对象属性。<br>稀疏数组： <br><br>////<strong>包含从0开始的不连续索引的数组。此时length属性值大于元素的个数。</strong><br>e.g. a[1000] = 0; //赋值添加一个元素，但是设置length为1001<br><strong>注意</strong>当在数组直接量中省略值时不会创建稀疏数组。省略的元素在数组中是存在的，值是undefined。<br>e.g. var a1 = [,,,]; //数组是[udnefined,undefined,undefined]<br>     var a2 = new Array(3); //该数组根本没有元素<br>     o in a1; //true:a1在索引0处有一个元素<br>     o in a2; //false:a2在索引0处没有元素<br>数组长度： <br><br>////若为一个数组元素赋值，它的索引i大于或等于现有数组的长度时，length属性的值将设置为i+1;设置length的属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将删除。若数组元素不能配置则不能删除。<br>数组元素的添加和删除： <br><br>////push()方法在末尾添加一个或多个元素。返回数组新的长度。<br>e.g. a = []; //空数组<br>     a.push(“zero”); //a = [“zero”]<br>     a.push(“one”,”two”); a = [“zero”,”one”,”two”]<br>////delete运算符删除数组元素。<br>e.g. a = [1,2,3];<br>     delete a[1]; //删除索引为1的元素<br>     1 in a; //=&gt;false:数组索引1并未定义<br>     a.length; //3:delete操作不会影响数组长度<br>////unshift()方法在数组首部插入元素。返回数组长度<br>e.g. a = [1,2,3];<br>     a.unshift(“one”); //[one,1,2,3]<br>     a.unshift(“two”,”three”); //[“two”, “three”, “one”, 1, 2, 3]<br>////pop()方法使减少长度为1并返回被删除元素的值。<br>e.g. a = [1,2,3];<br>     a.pop(); //3:删除末尾的元素并返回被删除的元素3<br>////shift()方法从数组头部删除一个元素并将所有元素下移到比当前索引低1的地方。<br>e.g. a = [1,2,3];<br>     consolelog(a.shift()); //1:头部元素被删除<br>     console.log(a[1]); //3:所有元素的索引下移1<br>数组遍历： <br><br>////for循环<br>////forEach()方法 按照索引的顺序按个传递给定义的一个函数<br>e.g. var data = [1,2,3,4,5];<br>     var sumOfSquares = 0;<br>     data.forEach(<br>         function(x){ //把每个元素传递给此函数<br>             sumOfSquares += x<em>x;<br>         }<br>     );<br>     console.log(sumOfSquares);  //55<br>多维数组： <br><br>////e.g. var table = new Array(10);<br>         for(var i = 0; i &lt; table.length; i++)<br>         var table[i] = new Array(10);<br>         for(var row = 0; row &lt; table.length; row++){<br>             for(col = 0; col &lt; table[i].length; col++){<br>                 table[row][col] = row</em>col;<br>             }<br>         };<br>         var product = table[5][7];</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/14/JavaScript数组1/" data-id="cjf521e66000wwkv2o6n8gnmz" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript对象3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/13/JavaScript对象3/" class="article-date">
  <time datetime="2018-03-13T11:52:42.000Z" itemprop="datePublished">2018-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/13/JavaScript对象3/">JavaScript对象3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>枚举属性：e.g.var o = {x:1,y:2,z:3};<br>             o.propertyIsEnumerable(“toString”);<br>             for(p in o)<br>             console.log(p);<br>             // x<br>             // y<br>             // z 不会输出toString<br>    =&gt; 避免上述情况 过滤返回的属性<br>       for(p in o) {<br>           if(!o.hasOwnProperty(p)) continue; //跳过继承的属性<br>       }<br>       for(p in o) {<br>           if(typeof o[p] === “function”) continue; //跳过方法<br>       }<br>属性getter和setter：由getter和setter定义的属性称做“存取器属性”，不同于数据属性。不可写性。只有getter方法只读，只有setter属性只写，读取只写属性总是返回undefined。<br>属性的特征：数据属性特性：值、可写性、可枚举性、可配置性<br>           存取器属性不具有值和可写性，它们的可写性是由setter存在与否决定的。特性：读取、写入、可枚举性、可配置性。<br>对象的三个属性：原型、类、可扩展性。<br>原型属性：用来继承属性检测一个对象是否是另一个对象的原型，使用isProtptypeOf()方法。<br>可扩展性：表示是否可以给对象添加新属性。所有内置对象和自定义对象都是可扩展的，宿主对象的可扩展性是由JavaScript引擎决定的。<br>序列化对象：将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript5提供内置函数JSON.stringify()和JSON.parse()用来序列号和还原JavaScript对象。JSON JavaScript Object Notation JavaScript对象表示法。<br>对象方法： toString()方法返回表示调用这个方法的对象值的字符串<br>          e.g. var s = { x:1, y:1 }.toString();<br>               console.log(s);<br>               // [object Object]<br>          toLocaleString()方法返回这个对象的本地化字符串</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/13/JavaScript对象3/" data-id="cjf521e2q000bwkv290gitny0" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript对象2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/13/JavaScript对象2/" class="article-date">
  <time datetime="2018-03-13T11:52:25.000Z" itemprop="datePublished">2018-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/13/JavaScript对象2/">JavaScript对象2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>属性的查询和设置：e.g. var author = book.author;<br>                     var title = book[“main title”]; //注意空格。ECMAScript3如果一个对象的属性名是保留字则必须用方括号的形式访问。ECMAScrit5放宽了限制，可以在点运算符后直接使用保留字。<br>作为关联数组的对象：object[“property”]通过字符串索引 -&gt; 关联数组<br>                  JavaScript对象都是关联数组。<br>                  当通过点运算符访问对象的属性时，属性名用一个标识符来表示。标识符必须直接出现在JavaScript程序中，它们不是数据类型，所以程序无法修改他们。<br>                  当通过[]来访问对象属性时，属性名通过字符串来显示。字符串是JavaScript的数据类型在程序运行时和修改和创建。<strong>字符串值是动态的。</strong><br>                  function getvalue(portfolio){<br>                  var total = 0.0;<br>                  for(stock in portfolio){ //遍历portfolio中的每只股票<br>                  var shares = portfolio[stock]; //得到每只股票的份额<br>                  var price = getquote(stock); //查找股票价格<br>                  total += shares * price;<br>                  }<br>                  return total;<br>                  }<br>继承：JavaScript对象具有自有属性，也有属性是从原型对象继承而来的。<br> e.g. var o = {}; //o从Object.prototype继承对象的方法<br>      o.x = 1; //给o定义一个熟悉x<br>      var p = inherit(0); //p继承o和Object.prototype<br>      p.y = 2; //给p定义一个熟悉y<br>      var q = inherit(p); //q继承p、o和Object.prototype<br>      q.z = 3; //给q定义一个熟悉z<br>      var s = q.toString(); //toString继承Object.prototype<br>      q.x + q.y; //=&gt;3:x和y分别继承自o和p<br>     如果o继承自一个只读属性x，那么赋值操作不允许。只有在查询属性时才会体验到继承的存在，设置属性和继承无关。<br>     var unitcircle = { r:1}; //一个用来继承的对象<br>     var c = inherit(unitcircle); //c继承属性r<br>     c.x = 1; c.y =1;  //c定义两个属性<br>     c.r = 2; //c覆盖继承来的属性<br>     unitcircle.r; //=&gt;,原型对象没有修改<br>     对象o设置属性p会失败：1 o的属性p是只读的：不能给只读属性重新赋值<br>                        2 o中的属性p是继承属性，且它是只读的<br>                        3 o中不存在的自有属性p<br>删除属性：delete运算符可以删除对象的属性。不会操作属性中的属性。<br>         <strong>只能删除自有属性，不能删除继承属性。</strong><br>         delete不能删除那些可配置性(意味着能修改属性的行为，让该对象的属性都是不可迭代的、不可修改的和不可配置的)为false的属性，某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。<br>检测属性：判断某个属性是否存在于某个对象中。可通过in运算符、hasOwnProperty()和propertyIsEnumerable()方法来完成这个工作。<br>in运算符的左侧是属性名，右侧是对象。若对象的自有属性或继承属性包含这个属性则返回true。<br>e.g. var o = { x:1 };<br>     “x” in o; //true: “x”是o的属性<br>     “y” in o; //false： “y”不是o的属性<br>     “toString” in o; //true：o继承toString属性<br>hasOwnProperty()检测给定的名字是否是对象的自有属性。对于继承属性将返回false。<br>e.g. var 0 = { x:1 };<br>     o.hasOwnProperty(“x”); //true:o有一个自有属性x<br>     o.hasOwnProperty(“y”); //false:o中不存在属性y<br>     o.hasOwnProperty(“toString”); //false:toString是继承属性<br>propertyIsEnumerable()是hasOwnProperty()的增强版，只有检测到是自有属性且属性的可枚举性为true时才返回true。某些内置属性不可枚举。<br>!== 判断一个属性是否是undefined。<br>e.g. var o = { x:1 };<br>     o.x !== undefined; // true:o中有属性x<br>     o.y !== undefined; //false:o中没有属性y<br>     o.toString !== undefined; //true:o继承toString属性<br>有一种场景只能使用in运算符而不能使用上述属性访问的方式。in可以区分不存在的属性和存在但是值为undefined的属性。<br>e.g. var o = { x:undefined }; //属性被显式赋值为undefined<br>     o.x !== undefined; //false:属性存在，但值为undefined<br>     o.y !== undefined; //false:属性不存在<br>     “x” in o; //true:属性存在<br>     “y” in o; //false:属性不存在<br>     delete 0.x; //删除了属性x<br>     “x” in o; //false:属性不再存在</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/13/JavaScript对象2/" data-id="cjf521e1u0007wkv2p6gb1xky" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript对象1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/13/JavaScript对象1/" class="article-date">
  <time datetime="2018-03-13T11:50:38.000Z" itemprop="datePublished">2018-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/13/JavaScript对象1/">JavaScript对象1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>内置对象：由ECMAScript规范定义的对象或类。数组、函数、日期和正则表达式都是内置对象。<br>宿主对象：由JavaScript解释器所嵌入的宿主环境（如WEB浏览器）定义的。客户端JavaScript中表示网页结构的额HTMLElement对象均是宿主对象。可当成普通的JavaScript函数对象，也可当成内置对象。<br>自定义对象：由运行中的JavaScript代码创建的对象。<br>自有属性：直接在对象中定义的属性。<br>继承属性：在对象的原型对象中定义的属性。<br>所有通过对象直接量创建的对象都具有同一个原型对象，并可通过JavaScript代码Object.prototype获得对原型对象的引用。通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性的值(第一个参数是这个对象的原型)。<br>e.g. var o1 = Object.create({x:1,y:2}); //对象o1继承属性x和y<br>     var o2 = Object.create(null); //对象o2没有原型<br>** Object.create() ：是静态函数，不是提供给某个对象调用的方法。<br>     var o3 = Object.create(Object.prototype); //o3和new Object()一样，创建普通空对象传入Object.prototype可通过任意原型创建新对象，可使任意对象继承。<br>     function inherit(p){<br>        if(p == null) throw TypeError();<br>        if(Object.create)<br>        return Object.create(p);<br>        var t = typeof p;<br>        if(t !== “object” &amp;&amp; t !== “function”) throw TypeError();<br>        function f() {};<br>        f.prototype = p;<br>        return new f();<br>     }<br>     inherit()函数不能通过传入null原型来创建对象(Object.create()可创建没有原型的新对象)，且不能接受可选的第二个参数。不是将对象直接作为参数传入函数，而是将它的继承对象传入函数。当函数读取继承对象的属性时，实际读取的是继承来的值。给继承对象赋值不会影响原始对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/13/JavaScript对象1/" data-id="cjf521e1e0005wkv28s2goy3h" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript语句" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/12/JavaScript语句/" class="article-date">
  <time datetime="2018-03-12T12:45:08.000Z" itemprop="datePublished">2018-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/12/JavaScript语句/">JavaScript语句</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>复合语句：结尾不需要分号，块中原始语句必须以分号结束，语句块不需要；注意整齐。<br>声明语句：var用来声明一个或多个对象；<br>         function定义函数。<br>条件语句：if/else、else if(代码中有多条分支)<br>         switch(所有分支依赖于同一个表达式) break跳出switch语句或循环语句。<br>循环：while、do/while(关键字do标识循环开始，用while来标识循环的结尾并进入循环条件判断)、<br>    for、for/in(不会遍历对象的所有属性，只有“可枚举”的属性才会遍历到)。<br>跳转：break(跳转到循环或者其他语句的结束，达到break条件立即退出整个循环)<br>    continue(中止本次循环的执行并开始下一次循环的执行)<br>    return(解释器跳出函数体的执行，并提供调用的返回值)<br>    throw(触发或“抛出”一个异常)<br>标签语句：标识符和冒号组成 给一个语句加标签，在程序其他地方可以使用这个名字标记任何语句。<br>throw语句：抛出异常时立即停止当前正在执行的逻辑，跳转至就近的异常处理程序。<br>try/catch/finally语句：语句块都需要使用花括号，catch从句跟在try从句之后，try块内某处发生异常调用catch内的代码逻辑。catch从句后跟随finally块，后者中放置清理代码，不管try块中是否异常，finally内逻辑总是执行。<br>e.g function trycatch () {<br>    var array = [234],<br>        newdate = new Date(),<br>        fun = function(){},<br>        is = 12.22,<br>        call;<br>    try{<br>        throw array + ‘\n’ + newdate.toLocaleString() + ‘ \n’ + fun.prototype.constructor +<br>        ‘\n’ + (typeof is == ‘number’) +’ \n’ + call ; //小心local后面还有一个’e’<br>    }<br>    catch(e){<br>        console.log(e);<br>    }<br>    finally{<br>        console.log(‘err finally’);<br>    }<br>}<br>trycatch ()<br>//  输出：</p>
<p>// 234</p>
<p>// 2018/3/13 上午9:55:02 </p>
<p>// function (){}</p>
<p>// true </p>
<p>// undefined</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/12/JavaScript语句/" data-id="cjf521e7u0015wkv2q8ldoypu" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript笔记/">JavaScript笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/12/JavaScript简介/" class="article-date">
  <time datetime="2018-03-12T10:32:30.000Z" itemprop="datePublished">2018-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript笔记/">JavaScript笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/12/JavaScript简介/">JavaScript简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JavaScript发明者布兰登 艾奇(Brendan Eich)<br>JavaScript组成：核心(ECMAscript) 提供核心语言功能<br>                文档对象模型(DOM) 提供访问和操作网页内容的方法和接口<br>                浏览器对象模(BOM) 提供与浏览器交互的方法和接口<br>在HTML用 script 元素插入JavaScript<br>所有 script 元素都会按照先后顺序依此被解析。(在不使用 defer 和 async 的情况下)<br>async：可选 立即下载脚本，不妨碍页面中的操作。只对外部脚本文件有效。<br>charset：可选 src属性指定的代码的字符集。<br>defer：可选 脚本可延迟到文档完全被解析和显示之后再执行。只对外部文件有效。IE7及更早版本对嵌入脚本也支持这个属性。<br>src：可选 执行代码的外部文件。<br>type： text/JavaScript<br>现代WEB应用程序一般把全部JavaScript引入放在 body 元素中的内容后面。<br>延迟脚本：延迟脚本会按照出现顺序执行，最好只包含一个脚本。放在页面底部最佳。<br>异步脚本：不保证按照指定它们的顺序执行。<br>嵌入文件与外部文件：尽可能使用外部文件。可维护性、可缓存、适应未来。<br>noscript 元素：浏览器不支持脚本/支持脚本被禁用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/12/JavaScript简介/" data-id="cjf521e6u000xwkv26n2i5p1b" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/简介/">简介</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TEST" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/12/TEST/" class="article-date">
  <time datetime="2018-03-12T04:40:27.000Z" itemprop="datePublished">2018-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/日志/">日志</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/12/TEST/">TEST</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hello World ! HEXO !</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/12/TEST/" data-id="cjf521e7q0013wkv2xahjao6b" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开始/">开始</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日志/">日志</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript笔记/">JavaScript笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript笔记/">JavaScript笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开始/">开始</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日志/">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简介/">简介</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/JavaScript笔记/" style="font-size: 10px;">JavaScript笔记</a> <a href="/tags/开始/" style="font-size: 10px;">开始</a> <a href="/tags/日志/" style="font-size: 20px;">日志</a> <a href="/tags/简介/" style="font-size: 10px;">简介</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/23/AJAX/">AJAX</a>
          </li>
        
          <li>
            <a href="/2018/03/23/JSON/">JSON</a>
          </li>
        
          <li>
            <a href="/2018/03/23/闭包/">闭包</a>
          </li>
        
          <li>
            <a href="/2018/03/23/递归/">递归</a>
          </li>
        
          <li>
            <a href="/2018/03/18/jQuery类库/">jQuery类库</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>